Testing in the new infra relies on the testing infrastructure provided by
Autotools (Automake, Autoconf, etc., see [1]). It is actually pretty simple:

# write a shell script, perl script, or other executable, and return correct
  exit values
# add that executable to the {{TESTS}} variable in the {{Makefile.am}} file in
  the dir where the executable is located

The possible exit values are:

* 0 - the test succeeded
* 77 - the test was skipped for some reason
* 99 - a hard failure (such as segmentation fault, etc - not very useful to us)
* any other value - the test failed

If you have tests that ''should'' fail, then you assign the value of those
executables to the variable {{XFAIL_TESTS}} (in addition to to the variable
{{TESTS}}).

If you need to reference data files, you have access to the variable {{$srcdir}}
(both from Automake and from the environment). This variable points to the
source directory of the test script, ie the dir in which the Makefile.am file is
located. ''Every other location must be relative to this dir!'' If done
properly, the tests will then work also when the source code is built and tested
out-of-source.

Test scripts can be as simple or complicated as you want, as long as it
fullfills the basic requirements:

* correct exit value (see above)
* all path and file references are relative to the local dir, specified using
  {{$srcdir}}

Here is an example of a very simpe test script (a shell script):

{{{
#!/bin/sh
TOOLDIR=$srcdir/../../tools/src
for i in "" .sfst .ofst .foma; do
    if ((test -z "$i") || $TOOLDIR/hfst-format --list-formats | grep $i > /dev/null); then
        if test -f cat2dog$i ; then
            if ! $TOOLDIR/hfst-invert cat2dog$i > test ; then
                exit 1
            fi
            if ! $TOOLDIR/hfst-compare -s test dog2cat$i  ; then
                exit 1
            fi
            rm test;
        fi
    fi

done
}}}

The script (taken from the Hfst3 distro) loops over the fst suffixes, and for
each suffix, tests whether such an fst exists, then tries to invert it and then
compare it. If any of the tools {{hfst-invert}} or {{hfst-compare}} fails, the
shell script exits with a value of 1, ie the whole shell script - and thus the
test - fails.

This script can easily be adapted and extended for our purposes, to e.g. test
that the output of an analysis matches a certain expected output ({{diff}}
should exit with {{0}}), or that certain input words all give at least one
suggestion, etc.

!!!Existing shell scripts for testing

Presently (January 2014) there are quite a few shell scripts for testing the
morphology and the lexicon, and nothing else. The following shell scripts are
found for all languages:

* {{generate-noun-lemmas.sh}}          - will check that the lemma can generate itself
* {{run-gt-desc-yaml-testcases.sh}}    - will run all yaml tests written for the ''descriptive'' analyser/generator
* {{run-gt-norm-anayaml-testcases.sh}} - will run yaml test for ''analysis only'' against the normative analyser
* {{run-gt-norm-genyaml-testcases.sh}} - will run yaml test for ''generation only'' against the normative generator
* {{run-gt-norm-yaml-testcases.sh}}    - will run all yaml tests written for the ''normative'' analyser/generator
* {{run-lexc-testcases.sh}}            - will run tests written as part of the lexc source files

Many languages have an extensive set of so called YAML tests, test data written
in the yaml format. Some also have tests written directly in the lexc source
code. But we need more tests. Please use the receipt here to add more tests for
all sorts of testing needs.

!!!Footnotes

[#1] [https://www.gnu.org/software/automake/manual/html_node/Scripts_002dbased-Testsuites.html]
