Presently we have three types of morphology testing:

* lemma generation
* yaml tests
* lexc tests

These will briefly be presented here, with instructions on how to adapt or
augment them.

!!!Lemma generation

Included from the {{und}} template there is a simple shell script to test lemma
generation for nouns. The basic idea is simple: extract all lemmas in the
lexicon (in the {{src/morphology/stems/}} dir), and try to generate the lemma.
It should always succeed.

In practice it is a bit more complicated, and the script may also need some
adaption to each language.

The adaption is basically that one needs to check that the tag string used for
generating the lemma form actually corresponds to what is used in the language
(and there are languages where the concept of a "lemma" doesn't make that much
sense - if that is so, remove the test script by removing it from the {{TESTS}}
variable in {{Makefile.am}}).

Complicating factors might be that some nouns do not inflect in singular (the
usual lemma form), and other forms of irregular lemma creation.

The template only gives noun lemma generation, but it is easy to use that script
as a tempate for doing teh same for verbs, adjectives and proper nouns. At least
North, Julev and South Sámi have more elaborate test scripts for all of these
parts-of-speeches. Have a look there for inspiration.

!!!Yaml tests

The most widely used morphological testing are the Yaml tests. The data format
is simple and straightforward, with a simple header followed by the actual test
data:

{{{
Config:
  hfst:
    Gen: ../../../src/generator-gt-norm.hfst
    Morph: ../../../src/analyser-gt-norm.hfst
  xerox:
    Gen: ../../../src/generator-gt-norm.xfst
    Morph: ../../../src/analyser-gt-norm.xfst
    App: lookup

Tests:
  Noun - atim - ok : # -m animate noun
    atim+N+AN+Sg: atim # this is a comment
    atim+N+AN+Pl: atimwak # test
    atim+N+AN+Loc: atimohk # really rare form
}}}

The yaml syntax is simple, but relies on indenting: two spaces for each level of
data structure nesting.

The header is started by the keyword {{Config}}, and lists fst's to be used for
analysis and generation, for both Xerox and Hfst. The path is relative to the
test dir {{test/src/morphology/}}.

The test data is similarly started by the keyword {{Tests}}, followed by a line
containing the name of the test ({{Nound - atim - ok}} in the example above).
On the following lines there are one line for each morphosyntactic form, using
the notation {{analysis string}} followed by colon, followed by
{{wordform string}}. If there are more than one possible wordform, they are all
on the same line, separated by comma and space, and enclosed in square brackets:

{{{
     ненэцьʼ+N+Sg+Loc: [ненэцяӈгана, ненэцяӈгна]
}}}

Remember to always indent properly!

!!Negative Yaml tests

Sometimes it can be valuable to specify negative tests. Usually they should
notbe needed, since any overgeneration will be reported as a FAIL. It might
still be a good idea to test for word forms that are known to have caused
problems.

To specify a negative test, add a tilde in front of the word form in the Yaml
data, as follows:

{{{
gierehtse+N+Sg+Acc: [gierehtsem, ~gieriehtsem]
}}}

Now the Yaml test will only pass if the last word form given is NOT generated,
and is NOT giving any analyses.

!!Filenames for Yaml tests

The filenames for the yaml tests are built up with the following components:

* a descriptive part, anything ''but underscore'' goes
* an underscore
* an fst specificator
* an optional {{.ana}} or {{.gen}} specifier
* the suffix {{.yaml}}

The underscore is the separator between the "free" part and the fst specifier.
By specifying the fst as part of the filename, it is possible to write tests for
all of the produced fst's.

By specifying {{.ana}} or {{.gen}} before the {{.yaml}} suffix, only
''analysis'' or ''generation'' testing will be done on the data. This is useful
for testing transducers that do not naturally come in generation/analysis pairs.

!!!Lexc tests

It is also possible, and often a very good idea, to add test cases directly to
the LexC source code. The syntax is very similar to the Yaml syntax (and is
parsed and tested by the same machinery that uses the yaml files), and looks
like the following:

{{{
!!€gt-norm: adjectives
!!€ isvelihks    isvelihks+A+Attr
!!€ isveligs     isvelihks+A+Attr
!!€ isvelihks    isvelihks+A+Sg+Nom
!!€ isveligs     isvelihks+A+Sg+Nom
}}}

The first line specifies which transducer to run the test data against, followed
by colon and space, and then the name of the test. There must be __no space__
between the Euro sign and the transducer specifier, and __no space__ between the
transducer specifier and the following colon. The string {{!!€gt-norm:}} is
obligatory (you can replace {{gt-norm}} with another fst specifier if you want
to test agains e.g. a descriptive fst, or an fst with a different tagset), but
the name of the test (''adjectives'' in the case above) is optional. If not
specified, the name will be the last seen lexicon name above.

The rest of the lines specify the test data, one line per word form, in two
columns: the first column contains the surface wordform, and the second column
the corresponding analysis string.

__Positive tests__ are specified with the string {{!!€}} at the very beginning
of the line, whereas __negative tests__ are specified by the string {{!!$}} at
the beginning of the line:

{{{
! Test data:
!!€gt-norm: gierehtse # Odd-syllable test
!!€ gierehtse           gierehtse+N+Sg+Nom
!!€ gierehtsen          gierehtse+N+Sg+Gen
!!€ gieriehtsasse       gierehtse+N+Sg+Ill
!!€ gierehtsem          gierehtse+N+Sg+Acc
!!$ gieriehtsem         gierehtse+N+Sg+Acc
}}}

Note the last line, where we explicitly check that the illegal word form
{{gieriehtsem}} is never generated or accepted.

Note that there __must__ be a space between {{!!€}} or {{!!$}} and the following
word form in the test data.
