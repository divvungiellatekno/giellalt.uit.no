<?xml version = '1.0' encoding = 'UTF-8'?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document xml:lang="en">
  <header>
    <title>Testing tools for the sámi LT project</title>
    <authors>
      <person email="sjurnm@mac.com" name="Sjur Moshagen" />
    </authors>
  </header>
  <body>
    <section>
      <title>Testing tools for the sámi language technology project</title>
      <section>
        <title>- Technical documentation -</title>
        <p>This page documents the scripts and the Makefile used as test tools. There are five perl scripts, all located in <code>$CVSROOT/gt/script/testing/</code>, and a Makefile, one copy for each language, located in <code>$CVSROOT/gt/smX/testing/</code> (where <code>smX</code> is the ISO code of your favourite Saami language). The Southern Saami (sma) Makefile is used as the development version, and serves as the original, from which the others are copied.</p>
        <p>Below is only described the calling and the return values of the different scripts, for details, see the scripts themselves, they are pretty simple, and fairly well commented (and if not, complain to me).</p>
      </section>
      <section>
        <title>1. merge-codesNforms.pl</title>
        <section>
          <title>Purpose:</title>
          <p>To create a base file for making test cases by combining a tag list and a word form list. This way we only have to write the tag list once for each POS.</p>
          <section>
            <title>Input:</title>
            <ul>
              <li>
                <code>ARG1:</code> input file with inflectional tags, one tag on each line; normally one of the files listed below (the filenames are not hardcoded, but given by the Makefile): <ul>
                  <li>
                    <code>noun-codes.txt</code>
                  </li>
                  <li>
                    <code>verb-codes.txt</code>
                  </li>
                  <li>
                    <code>adj-codes.txt</code>
                  </li>
                </ul>
              </li>
              <li>
                <code>ARG2:</code> input file with inflected word forms, in the same order as the tags; two or more alternate word forms on the same line, separated by a comma ONLY</li>
            </ul>
          </section>
          <section>
            <title>Output stream:</title>
            <p>A repeating, tab-separated list of fields (three fields), each such triple separated with a newline:</p>
            <ul>
              <li>
                <code>Field 1:</code> the baseform of the word</li>
              <li>
                <code>Field 2:</code> a morphological tag</li>
              <li>
                <code>Field 3:</code> the word form(s) corresponding to the tag; in the case of two or more alternative word forms, they are separated by a comma ONLY (no space).</li>
            </ul>
          </section>
        </section>
        <section>
          <title>Usage</title>
          <p>Used in front of one of:</p>
          <ul>
            <li>
              <a href="#GenTest" >3. <code>make-gen-test.pl</code>
              </a>
            </li>
            <li>
              <a href="#GenFaci" >4. <code>make-gen-test-facit.pl</code>
              </a>
            </li>
            <li>
              <a href="#AnaTest" >5. <code>make-ana-test.pl</code>
              </a>
            </li>
          </ul>
          <p>to create the actual test cases, and the corresponding facit files.</p>
        </section>
      </section>
      <section>
        <title>2. merge-codesNword.pl</title>
        <section>
          <title>Purpose:</title>
          <p>To create the input file for generating a paradigm by combining a tag list and a base form of a given word.</p>
          <section>
            <title>Input:</title>
            <ul>
              <li>
                <code>ARG1:</code> input file with inflectional tags, one tag on each line; normally one of the files listed below (the filenames are not hardcoded, but given by the Makefile): <ul>
                  <li>
                    <code>noun-codes.txt</code>
                  </li>
                  <li>
                    <code>verb-codes.txt</code>
                  </li>
                  <li>
                    <code>adj-codes.txt</code>
                  </li>
                </ul>
              </li>
              <li>
                <code>ARG2:</code> a word in its base form. The word has to belong to one of the major POSes N, A or V.</li>
            </ul>
          </section>
          <section>
            <title>Output stream:</title>
            <p>A list of baseform plus codes corresponding to the whole paradigm. There is one such combination on each line.</p>
          </section>
        </section>
        <section>
          <title>Usage</title>
          <p>The output can be directly used as input for <code>xfst</code>, to generate the word forms that make up the paradigm.</p>
        </section>
      </section>
      <section>
        <title>3. make-gen-test.pl</title>
        <section>
          <title>Purpose:</title>
          <p>To extract from a created testbase file the separate parts needed as input data for testing word form generation.</p>
          <section>
            <title>Input:</title>
            <p>A testbase file created with <a href="#CodForm" >1. <code>merge-codesNforms.pl</code>
              </a>, with the three fields baseform, inflectional codes, and word form(s) corresponding to the inflectional codes.</p>
          </section>
          <section>
            <title>Output stream:</title>
            <p>Test file for word form generation testing: one line for each inflection, consisting of baseform and inflectional codes appended. This is the input format required by the Xerox <code>xfst</code> tool.</p>
          </section>
        </section>
        <section>
          <title>Usage</title>
          <p>Use as input to the Xerox <code>xfst</code> tool (done in the Makefile).</p>
        </section>
      </section>
      <section>
        <title>4. make-gen-test-facit.pl</title>
        <section>
          <title>Purpose:</title>
          <p>To create the <strong>expected</strong> output from a generation test run, such that the actual test results can be compared with it. Based on the comparison, one can make further reports on the success of the test run.</p>
          <section>
            <title>Input:</title>
            <p>Testbase file as <a href="#CodForm" >created above</a>.</p>
          </section>
          <section>
            <title>Output stream:</title>
            <p>A list of word forms in the same format as produced by the Xerox tools, extracted from the testbase file. One word form on each line.</p>
          </section>
        </section>
        <section>
          <title>Usage</title>
          <p>Use the output of this script to diff against the actual test result (done in the Makefile). Any differences indicate possible errors in the morphological description.</p>
        </section>
      </section>
      <section>
        <title>5. make-ana-test.pl</title>
        <section>
          <title>Purpose:</title>
          <p>To create a test file (or a facit file) for morphological analysis by spitting out all the possible word forms with the corresponding analysis at the end, formated almost as the output from the Xerox <code>xfst</code> tool. Some further postprocessing is needed both for making the test case, and for creating the facit file. This is done in the <a href="#MakeFil" >Makefile</a>.</p>
          <section>
            <title>Input:</title>
            <p>A testbase file as created <a href="#CodForm" >above</a>.</p>
          </section>
          <section>
            <title>Output stream:</title>
            <p>A two-field, tab-separated list:</p>
            <ul>
              <li>
                <strong>Field 1:</strong> Wordform</li>
              <li>
                <strong>Field 2:</strong> Baseform_Codes</li>
            </ul>
            <p>In cases where there are more than one alternative wordform, they have been split onto separate lines.</p>
          </section>
        </section>
        <section>
          <title>Usage</title>
          <p>Use to create the basis for word form analysis testing. Further sorting and cutting (field 1 as test data, field 2 as facit data) is needed, and is done in the Makefile.</p>
        </section>
      </section>
      <section>
        <title>6. Makefile</title>
        <section>
          <title>l</title>
          <p>Whereas the perl scripts above are pretty short and simple, the Makefile used to automatise testing is pretty long and complex. Thus, the documentation is split into the following sections:</p>
          <ul>
            <li>Flow diagram for testing</li>
            <li>Variables</li>
            <li>Main sections of the Makefile</li>
          </ul>
          <section>
            <title>Flow diagram for testing</title>
            <p>Below is outlined the flow of action for the test bed. The example file is from South Sami, but the flow itself is language independent. The flow diagram illustrates word form generation.</p>
            <source>            -----------    ===========           The corresponding
   &quot;Files&quot;, | Scripts |  &amp; || Tools ||              make target
==================================================================
&quot;noun-codes.txt&quot;  &quot;n-even-col6-ie-full.txt&quot;
        \                 |
         ------------------------
         | merge-codesNforms.pl |
         ------------------------
                     ||
                     \/
    &quot;n-even-col6-ie-full.testbase&quot;                 n-%.testbase
       ||                  ||
       ||                  \/
       ||       ------------------------
       ||       |   make-gen-test.pl   |
       ||       ------------------------
       ||                  ||
       ||                  \/
       ||      &quot;n-even-col6-ie-full.gtest&quot;            %.gtest
       ||                  ||
       ||                  \/
       ||   ------------------------------------
       ||   | n-even-col6-ie-full-gtest-script |
       ||   ------------------------------------
       ||                  ||
       ||                  \/
       ||            ==============
       ||            ||   xfst   ||
       ||            ==============
       ||                  ||
       ||                  \/
       ||        &quot;n-even-col6-ie-full.gresult&quot;       %.gresult
       ||                              ||
       \/                              ||
  --------------------------           ||
  | make-gen-test-facit.pl |           ||
  --------------------------           ||
                 ||                    ||
                 \/                    ||
      &quot;n-even-col6-ie-full.gfacit&quot;     ||            %.gfacit
                        ||             ||
                        \/             \/
                        =================
                        ||     diff    ||
                        =================
                                ||
                                \/
                  &quot;n-even-col6-ie-full.greport&quot;      %.greport
                                ||
 all *.greport files - \  \  \  \/  / /  /
                        =================
                        ||     cat     ||
                        =================
                                ||
                                \/
                          &quot;n-g.summary&quot;             n-g.summary
</source>
            <p>The above scheme is repeated more or less identical for word form analysis, with the exception that there is no separate <code>-facit.pl</code> script - the same script is used for producing both test input and test facit, with the help of some postprocessing in the Makefile.</p>
            <p>The scheme for paradigm generation is much simpler, and it should be possible to read the Makefile directly. If not, <a href="mailto:sjurnm@mac.com" >complain to me!</a>
            </p>
          </section>
          <section>
            <title>Variables Used</title>
            <section>
              <title>Predefined Variables</title>
              <p>The following built-in variables are used:</p>
              <dl>
                <dt>$@</dt>
                <dd>Contains the name of the target, is often used to redirect output to a file named the same as the target.</dd>
                <dt>%</dt>
                <dd>(Strictly speaking not a variable:) Wildcard in target and dependency statements. When used as a wildcard in a target, the string it represents will be inserted in its place in names of dependencies. Often used to make one target for many similarly named files/targets.</dd>
                <dt>$&lt;
</dt>
                <dd>Represents the <strong>first</strong> element in a list of dependencies.</dd>
                <dt>$^</dt>
                <dd>Holds the name of <strong>all</strong> dependencies.</dd>
                <dt>$*</dt>
                <dd>Holds the string matched by % in a target name.</dd>
                <dt>MAKE</dt>
                <dd>Holds the pathname of the <code>make</code> program used. This is useful f.ex. when starting a <code>make</code> command in another directory from within a Makefile, to ensure they are using the same <code>make</code>.</dd>
              </dl>
            </section>
            <section>
              <title>Variables I have defined</title>
              <p>The following variables defined by me are used:</p>
              <dl>
                <dt>SHELL</dt>
                <dd>The location of the shell program. The use of this variable (set to this value) is recommended in the <code>make</code> documentation. That's why.</dd>
                <dt>BINDIR</dt>
                <dd>The location of the directory that holds the scripts used in testing.</dd>
                <dt>TEMP</dt>
                <dd>The location of the directory for storing temporary files (so that it can easily be redefined).</dd>
                <dt>SAVEFILE</dt>
                <dd>A variable containing the (computed) name of the save file used during testing. The computed content of this variable makes the reference to the save file language independent.</dd>
                <dt>UMASK</dt>
                <dd>Something I have copied from a Lingsoft makefile. I do not understand exactly what it does, and whether we need it. It does not seem to do any harm, so it is left for the time being.</dd>
                <dt>WORD</dt>
                <dd>An empty variable to be filled/set by the user (on the command line) when generating a paradigm.</dd>
                <dt>NGenFiles<br/> NAnaFiles<br/> VGenFiles<br/> VAnaFiles<br/> AGenFiles<br/> AAnaFiles</dt>
                <dd>Variables whose content is a list of target names (one for each POS, analysis and generation) calculated from (existing) file names. This is to circumvent a problem with being able to trigger the making of some files, due to the non-existence of other files (I have forgotten the details, but <em>with</em> it works, <em>without</em> it doesn't. Trust me.). If you are curious, see the <code>make</code> documentation.</dd>
              </dl>
              <p>When defined, the variable names are written as such, when referenced, they are encapsulated in parenthesis, and prefixed with a dollar sign. Example: <strong>$(TEMP)</strong> is how the variable <strong>TEMP</strong> is referenced.</p>
            </section>
          </section>
          <section>
            <title>Main sections of the Makefile</title>
            <p>The main sections of the Makefile are the following:</p>
            <ul>
              <li>Variable definitions</li>
              <li>Main targets, housekeeping targets</li>
              <li>POS-specific targets, one section each for N, V and A. The three sections are identical apart from the POS variation. (It is not possible to merge these targets into a smaller, POS-independent set without a major rework. It will not be done.)</li>
              <li>POS-UNspecific targets for running the tests</li>
            </ul>
          </section>
        </section>
      </section>
      
    </section>
  </body>
</document>
