<html xmlns:xi="http://www.w3.org/2001/XInclude" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>How to test the spellers</title>
   </head>
   <body>
      <h1>Automatic testing</h1>
      <p>We now have a test bench for automatic testing of the spellers, using
         different data sets. The data sets/tests serve different purposes, and
         are the following:
      </p>
      <ul>
         <li><strong>regression-test:
               </strong><br>tests the speller against a set of known problematic misspellings
            and correct words, to check that newer versions don't break earlier
            fixes; the data set will often contain "constructed" words made to
            highlight certain morphological constructions
         </li>
         <li><strong>typos-test:
               </strong><br>tests the speller against a collection of real typographic errors
            and their corrections, as found in our corpus documents or elsewhere
            in real texts â€” the purpose of the test is to see how well the speller
            handles real errors, both when it comes to detecting them, and to give
            the correct suggesion; the data set should <em>never</em> contain
            constructed errors
         </li>
         <li><strong>baseform-test:
               </strong><br>extracts all baseforms (=nominative singular, infinitive) found in
            our lexicons, and send them through the speller; to ensure that the
            lexicon is well-formed and that the speller actually recognises all
            (baseforms of the) words it should
         </li>
         <li><strong>correct-test:
               </strong><br>runs complete documents manually marked up with error/correction
            tags through the speller; this test will check both lexical coverage,
            calculate precision, recall and coverage, as well as give an idea of
            the quality of the suggestions; for details on marking up documents to
            be used as input, see <a href="error-markup.html">this page</a></li>
      </ul>
      <p>Below we have briefly described how to run these automatic tests, how
         to read the test reports, and then some more details on each test.
      </p>
      <h2>Running automatic tests, storing results</h2>
      <p>To run each of the automatic tests above, just <code>make</code>
         the test name as given, and the <code>TARGET</code> as usual (in the
         <code>gt/</code> directory), e.g.:
      </p>
      <pre xml:space="preserve">make regression-test TARGET=sme</pre>
      <p>There is one exception, and that is the correct-test, which also
         requires a DOC input parameter - the correct document used as input
         data:
      </p>
      <pre xml:space="preserve">make correct-test TARGET=sme DOC=somedoc.correct.doc.xml</pre>
      <p>There is a short-cut <code>make</code> target that will run all but
         the <code>correct-test</code> at once:
      </p>
      <pre xml:space="preserve">make spelltest TARGET=smj #will run regression, typos &amp; baseform</pre>
      <p>In addition, it is possible to specify the tool used for the actual
         testing, that is, the speller engine, by giving <code>make</code> the
         parameter <code>TESTTOOL</code>, with one of the following values:
      </p>
      <ul>
         <li><strong>pl:
               </strong><br>polderland command-line speller
         </li>
         <li><strong>mw:
               </strong><br>Microsoft Word as the engine, iterating over each of the words
            in the input data, and asking Word about its spelling status;
            AppleScript is used to tell Word what to do, and to collect the
            response from Word
         </li>
      </ul>
      <p>In the future, more spelling engines will be added, like hunspell
         (<strong>hu</strong>) and possibly aspell (<strong>as</strong>).
      </p>
      <p>The <strong>mw</strong> test engine has some shortcomings due to
         Word's AppleScript implementation (or our inability to find our way
         through the Word AppleScript dictionary), but it also has the nice
         feature to be comletely independent of the real speller engine behind
         Word. This means that it is possible to test other spellers than ours,
         and compare the test results across languages and speller engines
         (given reasonably similar input data).
      </p>
      <p>It is also possible to add the date of the test run as a parameter
         to <code>make</code>, if one for example would like to update an
         earlier test run with corrected test data. This is done with the
         parameter <code>DATE</code>. A full <code>make</code> command for the
         future hunspell tool would then look something like:
      </p>
      <pre xml:space="preserve">make correct-test TARGET=sme DOC=somedoc.correct.doc.xml TESTTOOL=hu DATE=20071020</pre>
      <p>The output from each test is two xml files, both stored in
         <code>gt/doc/proof/spelling/testing/</code>. One is a bare-bones
         standardised xml representation of the speller output, the other is a
         Forrest-doc xml file presenting both the direct test results and some
         calculated statistics. To save the test results for the future and at
         the same time make them available for others, the xml files should be
         checked in in <code>cvs</code>.
      </p>
      <p>Finally, to properly include the test results in the Forrest-driven
         site of ours, the forrest-doc files should also be added to the menu
         system by including a reference in the file
         <code>gt/doc/site-proof-frag.xml</code>.
      </p>
      <h2>regression-test</h2>
      <h3>Input data</h3>
      <p>The <code>regression-test</code> input data is stored i the file
         <code>$TARGET/polderland/regressions.txt</code>. The format is quite
         simple, and has two forms:
      </p>
      <pre xml:space="preserve">error&lt;TAB&gt;correction&lt;TAB&gt;#comment
correct&lt;TAB&gt;&lt;TAB&gt;!comment</pre>
      <p>Comments can either start with # or !. The first variant is a
         so-called <em>negative</em> test, where the speller should detect
         the <code>error</code> and give the <code>correction</code> as one
         of its suggestions. The other variant is consequently a
         <em>positive</em> test, where we check that the speller actually
         recognises correct word forms. Often missing correct suggestions or
         false negatives are caused by the <em>correct</em> form not being
         recognised. The positive tests will help in detecting such
         cases.
      </p>
      <h3>Reading the test report</h3>
      <p>The test report for the regression tests have seven main
         sections:
      </p>
      <ol>
         <li>Overview</li>
         <li>True positives</li>
         <li>False positives</li>
         <li>False negatives</li>
         <li>True negatives</li>
         <li>Grouped by bug #</li>
         <li>Testpairs not in bugs</li>
      </ol>
      <p>Each section is briefly described below.</p>
      <h4>Overview</h4>
      <p>This gives some basic statistics about the regression test. The
         most important figures here are the false negatives and false
         positives - they indicate how many testpairs are still
         failing.
      </p>
      <h4>True positives</h4>
      <p>Normally not very relevant reading - these are the correctly
         recognised misspellings.
      </p>
      <h4>False positives</h4>
      <p>This section lists correct input flagged as misspellings. Check
         this briefly to see if there are any patterns in the incorrectly
         flagged words. Often a few bugs are failing, so further
         investigation should be directed there.
      </p>
      <h4>False negatives</h4>
      <p>This is misspellings not detected by the speller. Again, check
         whether there is a pattern among the undetected misspellings.
      </p>
      <h4>True negatives</h4>
      <p>Normally not very relevant reading - these are the correctly
         recognised correct words.
      </p>
      <h4>Grouped by bug #</h4>
      <p>This is really the most relevant section. Here, all failings
         have a <em class="broken">light red background</em>, to make them
         stand out visually and be easy to spot. To get an overview of the
         situation for reported bugs, go directly to this section, and
         scroll through it looking for red rows.
      </p>
      <p>All bugs with no red rows can be closed (or should be already),
         whereas bugs with red rows (ie broken tests) need further
         investigation.
      </p>
      <p>For a test pair to show up in this section, the comment column
         in the test data has to start with the bug ID.
      </p>
      <h4>Testpairs not in bugs</h4>
      <p>This last section contains all test pairs not covered by the
         previous section, and is using the same redish background colour
         to indicate failed tests. It should be as small as possible, as we
         want most or all test pairs to be associated with a bug.
      </p>
      <h2>typos-test</h2>
      <h3>Input data</h3>
      <p>The <code>typos-test</code> input data is stored i the file
         <code>$TARGET/src/typos.txt</code>. The format is similar to the
         regression data file:
      </p>
      <pre xml:space="preserve">error&lt;TAB&gt;correction&lt;TAB&gt;#comment</pre>
      <p>Comments can either start with # or !.</p>
      <p>The data is a collection of true misspellings found in different
         sources. It should <em>NOT</em> contain any made-up examples (they
         can be put in the regression.txt file if relevant, otherwise don't
         use such data).
      </p>
      <p>As part of the testing, all the correct words are also extracted
         and used as input to the speller. These should all be accepted, and
         serve as positive test cases for the typos-test.
      </p>
      <h3>Reading the test report</h3>
      <p>The test report for <code>typos-test</code> contains the same
         first five sections as the regression-test report. The most
         important things to look at are the following points:
      </p>
      <ul>
         <li><strong>true positives without (correct) suggestions:
               </strong><br>why are the suggestion(s) missing?
         </li>
         <li><strong>false negatives:
               </strong><br>any pattern in the undetected misspellings
         </li>
         <li><strong>false positives:
               </strong><br>any pattern in the wrongly flagged words
         </li>
         <li><strong>overall statistics:
               </strong><br>our target is to detect and correct as many of the known typos
            as possible
         </li>
      </ul>
      <h2>baseform-test</h2>
      <h3>Input data</h3>
      <p>The <code>baseform-test</code> input data is generated as an
         extraction of all lexical entries in our <strong>LexC</strong>
         files, and is used to ensure that we actually recognise all the
         words that we put into the speller. Further, since we're really not
         interested in seeing the long list of <em>recognised</em> baseforms,
         the data is sent two times through the speller. The first round is
         used to identify all negative hits (ie all rejected baseforms), and
         the second round is used to only analyse those, to get both some
         statistics, suggestions (the suggestions can be quite telling about
         why a certain word was rejected) and filter out some cases that are
         actually recognised (the first filtering is a little
         over-active).
      </p>
      <h3>Reading the test report</h3>
      <p>The test report for <code>baseform-test</code> contains the same
         first five sections as the regression-test report. The most
         important things to look at are the following points:
      </p>
      <ul>
         <li><strong>number of false negatives:
               </strong><br>this should really go down to zero
         </li>
         <li><strong>false negative patterns:
               </strong><br>use any patterns to try to identify why groups of baseforms
            are rejected.
         </li>
         <li><strong>single entries:
               </strong><br>a substantial part of the unrecognised baseforms will be
            undetected errors in the lexicon; they should just be
            corrected
         </li>
      </ul>
      <h2>correct-test</h2>
      <h3>Input data</h3>
      <p>The <code>correct-test</code> input data is an xml document with
         errors and corrections marked up. The xml document is a conversion
         from a similarly marked-up corpus document, and represent our
         real-world test scenario for our spellers (the other test cases are
         different types of more technical testing).
      </p>
      <p>This test will usually have to be run several times on a new test
         document, as the first run will reveal inconsistencies and mistakes
         in the error/correction markup that needs to be fixed before we get
         reliable test results.
      </p>
      <p>The test document is read by <code>ccat</code>, which produces
         test data in a format identical to the other test types, that
         is:
      </p>
      <pre xml:space="preserve">error&lt;TAB&gt;correction&lt;TAB&gt;
correct&lt;TAB&gt;&lt;TAB&gt;</pre>
      <p>Since the input data is a complete document, it is possible to
         calculate reliable statistics on precision and recall.
      </p>
      <h3>Reading the test report</h3>
      <p>The test report for <code>baseform-test</code> contains the same
         first five sections as the regression-test report. The most
         important things to look at are the following points:
      </p>
      <ul>
         <li><strong>test statistics:
               </strong><br>in the <code>correct-test</code>, the precision and recall
            figures are real measures of the quality of our speller, and
            should be thoroughly followed between speller versions.
         </li>
         <li><strong>false negatives:
               </strong><br>that is, undetected spelling errors - these should be as few
            as possible
         </li>
         <li><strong>false positives:
               </strong><br>this number should also be low, although it is normally not
            possible to get down to zero
         </li>
         <li><strong>true positives without (correct) suggestions:
               </strong><br>we want to be able to correct as many of the detected
            misspellings as possible, which makes this category an interesting
            study object; it should be as small as possible
         </li>
      </ul>
      <h1>Manual testing</h1>
      <h2>Program Settings</h2>
      <p>In order to obtain measurable results, we set up the programs in
         the same way:
      </p>
      <ul>
         <li><strong>Common settings:
               </strong><br><ul>
               <li>Check Upper case words (turn off "Ignore Upper case")</li>
               <li>Check words with numbers (turn off "Ignore words with
                  numbers")
               </li>
               <li>Ignore words with numbers (leave this options on)</li>
            </ul>
         </li>
         <li><strong>MS Off/Mac:
               </strong><br>Word&gt;Preferences&gt;Spelling and Grammar
         </li>
         <li><strong>MS Off/Win:
               </strong><br>In the same location?
         </li>
      </ul>
      <h2>Types of testing</h2>
      <ul>
         <li>Technical testing</li>
         <li>Linguistic testing 
            <ul>
               <li>Testing the proofing</li>
               <li>Testing the suggestions</li>
            </ul>
         </li>
      </ul>
      <h2>Technical testing</h2>
      <h2>Linguistic testing: Testing the proofing</h2>
      <p>We test <code>precision</code>, <code>recall</code> and
         <code>accuracy</code>. Precision measures the actions of the program:
         Given that it indicates an error, can we trust that it actually is an
         error? The recall measures the robustness of the program: Given that
         we have written a misspelled word, what are the chances that the
         program finds it? These two measures are interlinked: A strict program
         will flag for errors often, find many, but also too many. On the
         contrary, a program acting on the safe side will flag an error only
         when sure to have found one, at the expence of letting through some
         erros. The former is better When users really want a correct text, and
         the latter is better when the user is annoyed by false alarms, and
         really just wants to get rid of the worst errors, at a minimal cost.
         Accuracy measures the overall perforance, and takes both the other
         measures into account
      </p>
      <p>To obtain these measures we need the following data:</p>
      <ul>
         <li><strong>words (wds):
               </strong><br>The number of words in the text
         </li>
         <li><strong>true positives (tp):
               </strong><br>The number of true errors found by the spellers (red
            errors)
         </li>
         <li><strong>false positives (fp):
               </strong><br>The number of correctly written words claimed to be errors by
            the program (correct words in red)
         </li>
         <li><strong>true negatives (tn):
               </strong><br>The number of correctly written words recognised as such
            (correct word, no red line)
         </li>
         <li><strong>false negatives (fn):
               </strong><br>The numbers of errors not found by the speller (misspelling
            without redline)
         </li>
      </ul>
      <p>We count wds, tp, fp, fn, and calculate tn as wds - (tp + fp + fn).
         The test values are calculated as follows (there is a spreadsheet
         available to do this automatically):
      </p>
      <ul>
         <li>precision = tp/(tp+fp)</li>
         <li>recall= tp/(tp+fn)</li>
         <li>accuracy = tp+tn/all</li>
      </ul>
      <h2>Linguistic testing: Testing the suggestions</h2>
      <p>Also here, we test for <code>precision</code>, <code>recall</code>
         and <code>accuracy</code>.
      </p>
      <p>To obtain these measures we need the following data:</p>
      <ul>
         <li><strong>errors (err):
               </strong><br>The number of errors in the text
         </li>
         <li><strong>true positives (tp):
               </strong><br>The number of true suggestions
         </li>
         <li><strong>false positives (fp):
               </strong><br></li>
         <li><strong>true negatives (tn):
               </strong><br></li>
         <li><strong>false negatives (fn):
               </strong><br></li>
      </ul>
      <ul>
         <li>precision = tp/(tp+fp)</li>
         <li>recall= tp/(tp+fn)</li>
         <li>accuracy = tp+tn/all</li>
      </ul>
   </body>
</html>