!!! Neahttadigisánit Configuration

Individual dictionary services are configured via a [YAML|http://www.yaml.org/refcard.html] file which is included
in the path on launch. The configuration file contains:

 * Main application settings: localisations, application subdomain/hostname, etc.
 * FST path and format definitions (compounding, tag structure, etc.)
 * Languages available
 * XML dictionary paths 
 * Wordform generation and analysis details
 * Wordform tag rewrites

Further configuration beyond this, formatting of lexicon entries, is covered
by other parts of the system.

For examples of configuration files, refer to the {{{configs/}}} directory.
Files are checked in, but when configuring these on an instance of a server,
make a copy and make changes locally. The "live" configs are kept out of SVN
just to ensure that they do not accidentally get checked in during
development.

!! Main application settings (ApplicationSettings)

The ApplicationSettings key contains the following configuration settings:

 * {{{app_name}}} - defines the name displayed in the menu bar, Neahttadigisánit, Nettidigisanat, etc.
 * {{{short_name}}} - a short name for the project, usually corresponding to the subdomain. This must be unique.
 * {{{default_locale}}} - the default locale to display of those available, when any other locale cannot be detected from the browser.*
 * {{{default_pair}}} - the default dictionary language pair to display
 * {{{locales_available}}} - internationalisations available*. It is important that these are defined as strings with quotes (YAML allows for strings to be defined without quotes as well), otherwise problems occur for Norwegian ("no"). Without the quotes, YAML will process this as a boolean value, but with quotes it is unambiguously a string.
 * {{{meta_description}}}, {{{meta_keywords}}} - these values will be inserted into the HTML {{{<meta />}}} tags in the header of all pages, and are important for search engines.


! *Note on locales

When defining locales for localization, it is important to use the two-character (ISO 639-1) code
if one exists for the language, otherwise use the three-character (ISO 639-2) code.

When defining language codes for dictionaries and morphological tools, use the three-character code always.

! Example

{{{
ApplicationSettings:
  app_name: "Nettidigisanat"
  short_name: "sanat"
  default_locale: "ru"
  default_pair: ["olo", "fin"]
  locales_available:
    - "fi"
    - "lv"
    - "ru"
    - "no"
  meta_description: >
     Free, mobile-friendly dictionaries for lots of languages.
  meta_keywords: >
     list, of, keywords
}}}

!! FST path and format definitions (Morphology)

The {{{Morphology}}} key contains a list of languages by ISO 639-2 code. Each language contains the following keys:

 * {{{tool}}} - path to the morphological tool
 * {{{file}}} - path to the morphological analysis file
 * {{{inverse_file}}} - path to the morphological generation file
 * {{{format}}} - format name ('xfst' currently only supported, but this value would probably also cover hfst) 
 * {{{options}}} - defined below

The options setting may contain the following keys:

* {{{compoundBoundary}}} - the part of a morphological analysis tag that marks the compound boundary, i.e.,: {{{lemma+Tag+Tag+CompoundTag+lemma2+Tag+Tag}}}. This will be used to split a compound word into multiple lemmas.
* {{{derivationMarker}}} - the part of a morphological analysis tag that marks a derivation. This is used in {{{sme}}} particularly, to only display non-derived analyses when one exists.
* {{{tagsep}}} - the character that separates tags and lemmas
* {{{inverse_tagsep}}} - the same, but for generation

{{{
  liv:
    tool: '/usr/bin/lookup'
    file: '/opt/smi/liv/bin/liv.fst'
    inverse_file: '/opt/smi/liv/bin/liv.fst'
    format: 'xfst'
    options:
      compoundBoundary: "+Use/Circ#"
      derivationMarker: "+Der"
      tagsep: '+'
      inverse_tagsep: '+'
}}}

!!! Notes

If you look at existing configuration files, you'll see YAML references used
to define paths to tools and such in one place, such that for development, it
is easier to change these things and switch to new directories.

{{{
Tools:
  xfst_lookup: &LOOKUP '/usr/bin/lookup'
  opt: &OPT '/opt/smi/'
 
Morphology:
  olo:
    tool: *LOOKUP
    file: [*OPT, '/olo/bin/olo.fst']
    inverse_file: [*OPT, '/olo/bin/iolo.fst']
}}}

Note how string concatenation is handled.

!! Languages covered by the system (Languages)

A list of language ISO codes covered by the system. This may be going away at some point, as its original purpose was language name translations, but for that it turned out better to use Python-Babel and gettext.

{{{
Languages:
  - iso: olo
  - iso: fin
  - iso: liv
  - iso: fkv
  - iso: izh
  - iso: nob
  - iso: est
  - iso: lav
}}}


!! XML dictionary paths (Dictionaries)

The dictionaries in the system. For now there are two different types of
definitions possible: a single direction dictionary, and a reversable
dictionary. The reasoning here is that some languages may have lexica
optimised for different directions. This is controlled by the key 'reversable'.

Dictionaries is a list of dictionaries, each dictionary defining the following keys: 

 * {{{source}}} - source language ISO (3 characters)
 * {{{target}}} - target language ISO
 * {{{path}}}
 * optional: {{{reversable}}} - true.

Example:

{{{
Dictionaries:
 - source: olo
   target: fin
   path: 'dicts/olo-fin.xml'
   reversable: true

 - source: liv
   target: fin
   path: 'dicts/liv.all.xml'
   reversable: true

 - source: liv
   target: est
   path: 'dicts/liv.all.xml'

}}}

NOTE: the reversable feature is shakily implemented at the present moment.
Test before releasing into the wild.

!! Wordform generation and analysis details (Paradigms)

The {{{Paradigms}}} section contains a part of speech (in all caps) and tag forms (minus
the part of speech) to generate forms for. The lists of tags here should be
the maximal set that will be generated for any given part of speech. If this
needs to be altered or reduced for any lexical set (i.e., singular only for
Proper nouns, or 3rd person only for specific weather verbs), rules for this
must be defined elsewhere.

If forms will be displayed, but pregenerated by some other rule, there must
be at least one entry for the part of speech. That set of tags will then be
passed to pregenerating functions and ignored, but, if the part of speech is
not set here, this will not happen.

{{{
Paradigms:
  olo:
    PRON:
      - "Pregenerate"
    N:
      - "Sg+Par"
      - "Sg+Apr"
      - "Sg+Gen"
      - "Pl+Par"
    V:
      - "Ind+Prs+ScSg1"
      - "Ind+Prs+ScSg3"
      - "Ind+Prs+ScPl3"
      - "Ind+Prt+ScSg1"
  liv:
    PRON:
      - "Pregenerate"
    N:
      - "Sg+Nom"
      - "Sg+Gen"
      - "Sg+Dat"
      - ... etc.
}}}

In the above example: "Pregenerate" is completely arbitrary and serves no programmatic function, however "PRON" being set is important.

!! Tag definitions (TagSets, TagTransforms)

Unfortunately it is not yet easy to use the babel and gettext translation
system to define what will be displayed to users. As such, YAML defines these things.


TagTransforms is a dictionary of language pairs, each of which contains
string pairs. Each string pair consists of the tag chunks from output from a
morphological tool (minus tag separator), and then the string that will be displayed to the users.

Each language pair is defined as the source language of the dictionary or
morphological tool, and then the language of the user interface and the formatting of this pair definition is important (see below). If
corresponding tags for the source dictionary - user interface pair are not
available, tags for the dictionary source language - dictionary target
language will be displayed. It may be useful to use aliases here too, but see
existing config files for examples.

{{{
TagTransforms:
  (olo, rus):
    "V": "v."
    "N": "s."
    "A": "adj."

  (liv, rus):
    "V": "v."
    "N": "s."
    "A": "adj."
}}}


NOTE: parentheses, comma, and space are important in the language pair
definition. Quotes are optional around the tag chunks on the left side, but
ideal to avoid any potential problem with conversion to strings.

! TagSets

TagSets aren't particularly relevant within the configuration file, but are
meant to be an aid in producing language-specific rules (see elsewhere in the
documentation, or docstrings for now). TagSets are defined first by language
they apply to, but then each tagset consists of a name, and then a list of
tags that goes along with the set.

{{{
TagSets:
  sme:
    pos: ["N", "V", "A", "Pr", "Po", "Num"]
    type: ["NomAg", "G3", "aktor"]
}}}



