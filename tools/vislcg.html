<html xmlns:xi="http://www.w3.org/2001/XInclude" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>The VISL Constraint Grammer Parser "vislcg"</title>
   </head>
   <body>
      <h1>WARNING!</h1>
      <p>This documentation is obsolete, and for the time being kept as reference. We now use
         vislcg3 (cf. separate documentation)
      </p>
      <h1>Introduction</h1>
      <p>"vislcg" is a constraint grammar parser, i.e., it is a program that
         selects the correct analysis in case of homonymy. The idea behind
         constraint grammars dates back to Fred Karlsson, as does its first
         version, CG-1, programmed in Lisp, the vislcg version presented here is
         Eckhardt Bick's open source implementation of Pasi Tapanainen's CG-2
         (written in C). This document is taken from the downloadable vislcg
         version at sourceforge.
      </p>
      <h1>The VISL Constraint Grammer Parser "vislcg"</h1>
      <p>This document describes the similarities and differences between CG-2
         and the vislcg Constraint Grammar parser. It is not, in its current
         form, intended as an introduction, tutorial, or reference to the CG
         formalism. Please refer to [Tapanainen, 1996]
      </p>
      <h1>Speed</h1>
      <p>vislcg is not designed for speed but performs reasonably well. On a
         Pentium II class PC, it disambiguates at about 1600 words per second
         using a morphological disambiguation grammar for Danish with about 1000
         rules. This is about 16% the speed of CG-2 on the same platform, with
         the same rules and the same input.
      </p>
      <h1>SGML tags and comments</h1>
      <p>vislcg does not currently support SGML tags in the input stream.</p>
      <h2>Modules</h2>
      <p>There are no separate parsers for different approaches or
         behaviors. The behavior of the vislcg parser is controlled by command
         line parameters (flags).
      </p>
      <h2>Flags</h2>
      <p>The command vislcg --help will list all supported parameters and
         flags, and a brief description of each:
      </p>
      <ul>
         <li><strong>--check-only:
               </strong><br>Test the syntax of the rules file and exit before performing any
            mappings or disambiguations.
         </li>
         <li><strong>--debug:
               </strong><br>Run compiler in debug mode.
         </li>
         <li><strong>--grammar=rulesfile or:
               </strong><br></li>
         <li><strong>--grammar rulesfile:
               </strong><br>Specifies which rules file to use. This option must be specified
            if any parsing is to be done.
         </li>
         <li><strong>--help:
               </strong><br>Print this text.
         </li>
         <li><strong>--minimal:
               </strong><br>Equivalent to --verbosity=minimal
         </li>
         <li><strong>--no-corrections:
               </strong><br>Do not apply any correction rules.
         </li>
         <li><strong>--no-mappings:
               </strong><br>Do not apply any mapping rules. This corresponds to CG-2's dis
            module
         </li>
         <li><strong>--prefix=marker or --prefix marker:
               </strong><br>This changes the special marker for ambiguity and mappings. The
            marker may be more than one character. The default marker is the '@'
            character.
         </li>
         <li><strong>--quiet:
               </strong><br>Do not output any messages. This option overrides any debug and
            trace options.
         </li>
         <li><strong>--reorder:
               </strong><br>Attempt to reorder rules in a way similar to CG-2, using
            PREFERRED-TARGETS and rules of thumb. [ The default is to apply
            rules in the strict order they appear in the rules file and ignore
            PREFERRED-TARGETS ]
         </li>
         <li><strong>--sections=n or --sections n:
               </strong><br>This sets the number (n) of CONSTRAINT sections that are
            applied. The default is to apply all sections.
         </li>
         <li><strong>--trace:
               </strong><br>Equivalent to --trace-mappings --trace-constraints.
         </li>
         <li><strong>--trace-constraints:
               </strong><br>Trace which constraints were applied and the order of
            application.
         </li>
         <li><strong>--trace-mappings:
               </strong><br>Trace which mappings were applied and the order of
            application.
         </li>
         <li><strong>--unsafe:
               </strong><br>Allow the compiler to remove the last reading of a cohort.
         </li>
         <li><strong>--verbose:
               </strong><br>Equivalent to --verbosity=verbose
         </li>
         <li><strong>--verbosity=level or --verbosity level:
               </strong><br>This option causes extra or less information to be printed in
            trace mode. Valid levels are: 
            <ul>
               <li><strong>'minimal':
                     </strong><br>- Line numbers of applied rules are attached to the output
                  cohorts. The output in minimal mode is similar to that of CG-2's
                  mdis.trace module.
               </li>
               <li><strong>'normal':
                     </strong><br>- Instead of attaching line numbers to readings, each rule
                  (the full specification - not just the line number) is printed
                  each time it is applied. [ 'normal' is the DEFAULT trace mode
                  verbosity.]
               </li>
               <li><strong>'verbose':
                     </strong><br>- As normal mode, but the cohort to which each rule was
                  applied is printed as well. This will also cause vislcg to print
                  all sets, mappings and constraints before processing any
                  input.
               </li>
            </ul>
         </li>
      </ul>
      <h1>Sections of the rule file</h1>
      <p>The section headers are DELIMITERS, PREFERRED-TARGETS, SETS,
         CORRECTIONS, MAPPINGS, CONSTRAINTS, and END. The sections SETS,
         CORRECTIONS, MAPPINGS, and CONSTRAINTS may be repeated any number of
         times.
      </p>
      <p>The CORRECTIONS section is a vislcg-specific extension of the CG
         formalism. See section 2.1.5a. ans 2.5a. for details.
      </p>
      <p>The minimal set of sections in a rule file is:</p>
      <pre xml:space="preserve">DELIMITERS
CONSTRAINTS

or

DELIMITERS
MAPPINGS

or

DELIMITERS
CORRECTIONS
</pre>
      <h2>2.1.5a. Section: CORRECTIONS</h2>
      <p>The correction rules handle lexical or other errors by substituting
         some tags with others in readings or appending new readings to
         cohorts. All corrections are applied after mappings, but before
         constraints.
      </p>
      <pre xml:space="preserve">SUBSTITUTE
</pre>
      <p>A SUBSTITUTE operation replaces tags with other tags in a
         reading.
      </p>
      <p>General form:</p>
      <p>"&lt;wordform&gt;" SUBSTITUTE (tag1 tag2 ...) (tag3 tag4 ...)
         TARGET (tag5 tag6 ...) IF (context1) (context2) ... ;
      </p>
      <p>The first list of tags (tag1 tag2 ...) is the list of tags to
         remove from the targetted reading. The second tag list (tag3 tag4 ...)
         is the list of tags to insert into the reading.
      </p>
      <p>If the contextual tests hold, any tag in the removal list that
         appears in the reading are deleted from the reading. Note that the
         tags in the removal list must be in the same order as those in the
         reading.
      </p>
      <p>The list of insertions is then inserted into the reading in place
         of the lastly removed tag. Note that the insertion will take place if
         just one of the tags in the removal list appeared in the reading.
      </p>
      <p>Often, the tags in the removal list should also appear in the
         target of the rule.
      </p>
      <pre xml:space="preserve">APPEND
</pre>
      <p>An APPEND operation adds an entire reading (a new line) - not just
         a sequence of tags as ADD and MAP operations do. No TARGET is used as
         APPEND does not address individual readings but an entire cohort (of
         readings).
      </p>
      <p>General form:</p>
      <p>"&lt;wordform&gt;" APPEND ("baseform" tag1 tag2) IF (context1)
         (context2) ... ;
      </p>
      <p>Examples</p>
      <pre xml:space="preserve"> # Remove the tags A and B from the target reading and insert the tag C.
 "&lt;something&gt;" SUBSTITUTE (A B) (C) TARGET (D) ;

 # Append the reading "another" A B C to cohorts with the wordform
 # " &lt;another&gt; " in the given context
 "&lt;another&gt;" APPEND ("another" A B C) IF (1 (D)) ;
</pre>
      <p>Syntax</p>
      <p></p>
      <ul>
         <li>The keyword CORRECTIONS begins the section.</li>
         <li>A correction rule is a list of items separated by blanks. The
            items are: 
            <ul>
               <li>For SUBSTITUTE 
                  <ol>
                     <li>an optional wordform,</li>
                     <li>the SUBSTITUTE keyword,</li>
                     <li>a removal tag list,</li>
                     <li>an insertion tag list,</li>
                     <li>an optional keyword TARGET,</li>
                     <li>a target tag (or set),</li>
                     <li>an optional keyword IF,</li>
                     <li>possibly several contextual tests.</li>
                  </ol>
               </li>
               <li>For APPEND 
                  <ol>
                     <li>an optional wordform,</li>
                     <li>the APPEND keyword,</li>
                     <li>an insertion tag list,</li>
                     <li>an optional keyword IF,</li>
                     <li>possibly several contextual tests.</li>
                  </ol>
               </li>
            </ul>
         </li>
         <li>The list may extend over several lines.</li>
         <li>The correction rule is terminated by the semicolon ";".</li>
         <li>There may be several correction rules.</li>
         <li>Comments may be added anywhere. The number-sign "#" begins a
            comment which then continue to the end of the line.
         </li>
      </ul>
      <h1>Symbols</h1>
      <h2>2.2.3 Positions</h2>
      <p>vislcg supports all the position and search features of CG-2:</p>
      <p></p>
      <ul>
         <li><strong>Relative position::
               </strong><br>0 = same cohort.
         </li>
         <li><strong>:
               </strong><br>1 = the next cohort to the right.
         </li>
         <li><strong>:
               </strong><br>-2 = the second cohort to the left.
         </li>
         <li><strong>Absolute position::
               </strong><br>@1 = the first cohort in the context.
         </li>
         <li><strong>:
               </strong><br>@-2 = the second to last cohort in the context.
         </li>
         <li><strong>Search::
               </strong><br>Continous search: (NOTE: see 2.4.5.2)
         </li>
         <li><strong>:
               </strong><br>**1 = search right, handling links specially.
         </li>
         <li><strong>:
               </strong><br>**-1 = search left, handling links specially.
         </li>
         <li><strong>:
               </strong><br>**-2 = search left, starting from the second cohort to the left,
            handling links specially.
         </li>
         <li><strong>Careful mode::
               </strong><br>Any position followed by the letter C will cause "careful"
            checking, i.e. every reading of the cohort has to belong to the
            given set. E.g.: (-1C (P)) will test whether all readings of the
            preceding cohort is P.
         </li>
      </ul>
      <h2>2.3.5. Set operations</h2>
      <h3>2.3.5.3. Intersection of sets (_)</h3>
      <p>SET I = S1 _ S2 ;</p>
      <p>The _ operation is subtly different from the way CG-2 behaves. In
         vislcg, the _ operator does not make the Cartesian product of the
         two operand sets, but instead asserts that to be a member of the set
         I, a reading must be a member of both S1 and S2. This means that the
         _ operation in vislcg is properly the intersection operation, not
         the Cartesian product or concatenation.
      </p>
      <p>Sets constructed using the _ operator in rules written for CG-2
         should behave identically when used in vislcg and CG-2.
      </p>
      <p>However, there may be subtle differences.</p>
      <p>E.g: In vislcg, the following two sets are equivalent:</p>
      <p>SET I1 = (A B) _ (C D) ;<br> SET I2 = (C D) _ (A B) ;
      </p>
      <p>Because the _ operation is the intersection operation in vislcg,
         the following readings will all be members of both I1 and I2:
      </p>
      <pre xml:space="preserve">        A B C D
    C D A B
    A C D B
</pre>
      <p>[ Note the reading A C D B. It is a member because it matches
         both (A B) and (C D). A D C B wouldn't be a member; it matches (A B)
         but not (C D). ]
      </p>
      <p>In CG-2, because the _ operation is the concatenation operation,
         the two sets are not equivalent. Only the reading A B C D is a
         member of I1 and only C D A B is a member of I2.
      </p>
      <p></p>
      <h3>2.3.5.4. Precedence</h3>
      <p>Operator precedence for set operations are as described for
         CG-2:
      </p>
      <ol>
         <li>_ and - from left to right;</li>
         <li>OR.</li>
      </ol>
      <p></p>
      <h2>2.3.6. Ambiguity Class (AND)</h2>
      <p>The ambiguity class operation (AND) is not supported by vislcg. To
         achieve the same effect that A AND N has in CG-2, use A LINK 0 N.
      </p>
      <p></p>
      <h2>2.4.2. Operations</h2>
      <p>The IFF operation is not supported.</p>
      <h2>2.4.4. Contextual tests</h2>
      <p>The handling of contextual tests is intended to be consistent with
         CG-2's behavior, but currently handles linked, careful, continous
         searches subtly different.
      </p>
      <p>Testing wordforms:</p>
      <p>Contextual test are tested against the wordforms of cohorts, too.
         Here, the wordform is interpreted as a reading with one tag: the
         wordform. E.g.: The test (1 ("&lt;$.&gt;")) will match a cohort which
         is a full stop.
      </p>
      <p></p>
      <h3>2.4.4.4. Same position</h3>
      <p>It _is_ possible in vislcg to have more than one contextual test
         for each position, e.g. the tests (1 A) (1 B) are legal in the same
         rule. This is contrary to CG-2, and no warning will be given.
      </p>
      <p></p>
      <h3>2.4.4.5. Complement</h3>
      <p>In negated contextual tests, such as</p>
      <pre xml:space="preserve">     (NOT context0 LINK context1 LINK context2)
</pre>
      <p>the negation is applied last and the rule is interpreted as</p>
      <pre xml:space="preserve">     ! (context0 &amp;&amp; (context1 &amp;&amp; context2)) /* C or Perl-like syntax */
</pre>
      <p>[Tapanainen 1996; 2.4.5. page 33]: "Here, the negation is applied
         last".
      </p>
      <p>In negated LINKed contexts, such as</p>
      <pre xml:space="preserve">     (context0 LINK NOT context1 LINK context2)
</pre>
      <p>the negation is applied only to context1, not to "context1 LINK
         context2" I.e.: the LINK to context2 will only be tested if context0
         matches /and/ the linked context1 does not. The above context test
         is therefore interpreted as
      </p>
      <pre xml:space="preserve">     context0 &amp;&amp; ( (!context1) &amp;&amp; context2)
</pre>
      <p>Combining the two above cases, the contextual test</p>
      <pre xml:space="preserve">     (NOT context0 LINK NOT context1 LINK context2)
</pre>
      <p>is interpreted as</p>
      <pre xml:space="preserve">     ! (context0 &amp;&amp; ( (!context1) &amp;&amp; context2))
</pre>
      <h2>2.4.5. Linking</h2>
      <p>Careful LINKs are supported, as well as the negated links mentioned
         above. E.g.:
      </p>
      <pre xml:space="preserve">     (*1 VFIN LINK 0C P)
     The next cohort to the right which has a reading belonging to the set
     VFIN is unambigously P.
</pre>
      <p>The above test is NOT equivalent to either</p>
      <pre xml:space="preserve">     (*1C VFIN _ P)
     To the right, there is a cohort which is unambigously both VFIN and P.
</pre>
      <p>or</p>
      <pre xml:space="preserve">     (*1C VFIN LINK 0 P)
     The next cohort to the right which is unambigously VFIN
     also has a reading which is P.
</pre>
      <p>or even (also with a careful link)</p>
      <pre xml:space="preserve">     (*1C VFIN LINK 0C P)
     The next occurrence of unambigous VFIN to the right is also
     unambigously P.
</pre>
      <p>LINKs may be both careful and negated. E.g.:</p>
      <pre xml:space="preserve">     (*1 A LINK NOT 1C B)
     The next occurrence of A to the right is immidiately followed by a
     cohort which is not unambigously B.
</pre>
      <h3>2.4.5.2. Continuous search</h3>
      <p>Continuous search is subtly different from CG-2.</p>
      <p>E.g.:</p>
      <pre xml:space="preserve">     (**1C A LINK 1 B)
     There is a cohort to the right which is unambigously A and
     followed by a cohort with a reading that is B.
</pre>
      <p>This seems to be inconsistent with CG-2 [Tapanainen 1996, 2.4.5.
         p.33]: "In careful mode, scanning stops at the first occurrence of A
         where the linked tests hold, i.e. the rule means that the next
         occurrence of A followed by B is unambigously A."
      </p>
      <p>In vislcg, scanning will not stop at the first occurrence of A
         followed by B. In continous search, the LINK will never be tested
         unless the preceeding test (1C A) holds, even in careful mode.
      </p>
      <p>E.g.: In visl-cg, but not in CG-2, the following input should
         satisfy the above contextual test (the target of the rule being the
         reading of "&lt;0&gt;"):
      </p>
      <pre xml:space="preserve">"&lt;0&gt;"
    X
"&lt;1&gt;"
    A
    X
"&lt;2&gt;"
    B
"&lt;3&gt;"
        A
    A
"&lt;4&gt;"
    B
</pre>
      <h1>Corrections</h1>
      <p>A correction rule modifies the information in the readings. Most
         often, this will be used to recover lexical errors.
      </p>
      <h2>2.5a.1. Correction Operations</h2>
      <p>There are two operations for correction rules.</p>
      <p>- The SUBSTITUTE operation removes specific tags from a reading and
         inserts new ones. A schematic SUBSTITUTE rule is
      </p>
      <pre xml:space="preserve">     "&lt;WORDFORM&gt;" SUBSTITUTE (REMOVAL TAGS) (INSERTION TAGS) TARGET (TARGET)
     IF (TEST1) (TEST2) ... ;
</pre>
      <p>The removal and insertion parts of a substitute rule are lists of
         tags. If the target reading has one or more of the removal tags, these
         will be removed from the reading and replaced by the insertion
         tags.
      </p>
      <p>- The APPEND operation appends a new reading to a cohort. A
         schematic APPEND rule is
      </p>
      <pre xml:space="preserve">     "&lt;WORDFORM&gt;" APPEND (INSERTION TAGS) IF (TEST1) (TEST2) ... ;
</pre>
      <p>The APPEND operation does not take a target because it operates on
         cohorts, not readings.
      </p>
      <h1>Rule order</h1>
      <p>The rule, target, and application ordering is not the same as for
         CG-2.
      </p>
      <p>The --no-reordering flag may be set, forcing the parser to always
         apply rules in the order of appearance in the rule file.
      </p>
      <p>Currently, reordering is done using the following priority list:</p>
      <p></p>
      <ol>
         <li>SELECT before REMOVE.</li>
         <li>SELECT rules targetting more preferred tags before rules
            targetting less preferred targets.
         </li>
         <li>REMOVE rules targetting less preferred tags before rules
            targetting more preferred targets.
         </li>
         <li>By order of appearance in rule file.</li>
      </ol>
      <p>This ordering may change arbitrarily in future versions.</p>
      <p>[ A possible future rule ordering is:</p>
      <ol>
         <li>Wordform rules before tag/set targets.</li>
         <li>SELECT before REMOVE.</li>
         <li>Negated contexts (NOT) first</li>
         <li>"Simple" rules before "complex" rules.</li>
         <li>Local positions before searches.</li>
         <li>Careful rules first. ]</li>
      </ol>
      <h2>2.6.1. Section order</h2>
      <h2>2.6.2. Target order</h2>
      <h2>2.6.3. Order in the rule file</h2>
      <h2>2.6.4. Application order of cohorts</h2>
      <h1>Debugging</h1>
      <h1>Debug Mode</h1>
      <p>The debug mode of the vislcg parser is similar to that of CG-2: In
         debug mode, the VISLCG compiler will issue a warning for every reading
         featuring a &lt;Correct!&gt; that the rule file would have removed if
         not run in debug mode.
      </p>
      <p>To run the rule file debugging option, the --debug option is invoked
         together with the vislcg command and the --grammar option. The benchmark
         corpus has initially been tagged by a parser and subsequently evaluated
         by human annotators, who have added the critical tag &lt;Correct!&gt; to
         each reading that was judged to be accurately tagged. The tagged
         benchmark corpus is fed into the parser using the new rule file as a
         test grammar. The syntax of this command line hence stipulates the
         indication of the rule file and the benchmark corpus input file used as
         input to the rule file as indicated by the greater-than sign:
      </p>
      <p>vislcg --grammar rulefilename --debug &lt; benchmarkcorpusname</p>
      <p>This corresponds to piping the corpus into vislcg by using the "cat"
         command:
      </p>
      <p>cat benchmarkcorpusname | vislcg --grammar rulefilename --debug</p>
      <p>You can debug a rule file (e.g. sandbox.txt) with IT Centre's
         benchmark corpus by typing:
      </p>
      <p>vislcg --grammar /home/cg-group/ sandbox.txt --debug &lt;
         /home/cg-group/bs-benchmark
      </p>
      <p>or</p>
      <p>cat /home/cg-group/bs-benchmark | vislcg --grammar /home/cg-group/
         sandbox.txt --debug
      </p>
      <p></p>
      <h1>Bibliography:</h1>
      <p>[Tapanainen, 1996]: Pasi Tapanainen. The Constraint Grammar parser
         CG-2. Publications of the Department of General Linguistics, University
         of Helsinki, no. 27. 1996. ISBN 951-45-7331-5
      </p>
      <p></p>
      <p>http://visl.sdc.dk</p>
   </body>
</html>