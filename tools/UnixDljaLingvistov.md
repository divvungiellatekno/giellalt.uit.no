# Unix для лингвистов

## Введение

Некоторые команды ОС Unix являются очень полезными инструментами для лингвистов - они способны обрабатывать объёмные массивы текстов быстро и эффективно. Чтобы быть в состоянии использовать эти команды, мы должны использовать интерфейс командной строки Unix. Это - краткое введение в Unix. После каждой секции маленькое резюме.

Команды Unix также найдены на Linux и на Mac OS X. Программа, которую мы используем, чтобы дать команды, обычно называют Терминалом (`terminal` или `xterm`). На MS Windows нет никакого Unix. Вы можете установить виртуальную машину Linux на Ваш Windows-компьютер.

Альтернативно, Вы должны иметь пользовательский аккаунт (учетная запись) на другом компьютере с системой Unix. Вы можете войти в этот компьютер и использовать экран и клавиатуру на Вашей Windows-машине. Чтобы войти в другой компьютер, Вы можете, например, использовать программу putty.exe.

Чтобы использовать Unix на Mac или Linux нужно просто запустить приложение  `Terminal` (Терминал). На Mac это расположено в папке программ, в подпапке `Utilities` (Утилиты). В Linux терминал-программа обычно находится в папке помощных программ. Мы теперь предполагаем, что у Вас есть доступ к Unix на Вашей собственной машине.

## Основные команды

## Команды, не щелчок мыши

Unix отличается от большинства других операционных систем в том, что у него нет графического интерфейса пользователя. Вместо того Unix имеет то, что мы называем командной строкой, т.е. курсор стоит и ждет, чтобы Вы вводили команду.

Прямо после того, как Вы открыли окно терминал-программы (и вошли в свою учетную запись, если надо), Вы находитесь в своем корневом каталоге. Налево от курсора есть короткий текст (приглашение), который говорит Вам, в каком папке Вы находитесь.

Вы теперь изучите много команд. Команды должны быть написаны определенным способом. У команды Unix есть две обязательных части: команда должна начаться с названия программы, и команда закончена, когда Вы нажимаете клавишу ENTER.

* Мы пробуем простую команду:
    - Напишите **date** и нажмитe ENTER.
    - В ответ Вы должны получить текущий день недели, дату и время.
* Другая команда:
    - Напишите **cal** и нажмите ENTER.
    - Ответ - маленький календарь.

С этого момента мы предположим, что Вы всегда нажимаете ENTER после команды. Поэтому "пишите **ls**" означает "пишите **ls**, и нажмите ENTER", и так же для других команд.

Большинство команд принимает один или несколько аргументов. Одна такая команда - **mkdir**, что означает, "делайте папку" или "создайте папку". Попробуйте его: Напишите **mkdir**, нажмите ENTER, и Вы получите логический ответ. Чтобы заставить папку нуждается по крайней мере один аргумент - имя папки. Напишите например **mkdir hogwash**.

Чтобы видеть, что произошло, напишите **ls** (перечислите содержание папки, в которой Вы находитесь). Папку, которую Вы только что сделали, можете теперь удалить с помощью команд **rmdir hogwash**. Попробуйте команду **rmdir**, и затем попробуйте ее снова. (Команда **rmdir** работает только с пустыми папками.)

С лингвистической точки зрения мы можем смотреть на команды как на глаголы. Так как все команды представляют наши запросы компьютеру, мы можем рассмотреть их как глаголы в императиве. Как другие глаголы так и Unix команды могуть быть переходными или непереходными. Например команда **date** - как непереходный глагол: Вы пишете **date**, и машина говорит Вам, какое сегодня число и день недели.

Команда **mkdir**, однако, является переходным глаголом, у нее должен быть объект (компьютерный термин для объекта: аргумент), а именно, название новой папки, которую Вы хотите создать.

Таким же образом как регулярные глаголы, команды Unix также работают с неявными объектамм. Интерпретация зависит от контекста. Если мы скажем "ещь!" мы обычно имеем в виду, "Ещь еду, которая находится перед тобой". У команды Unix **ls** также есть такой контекстно-зависимый, неявный объект. Команда **ls** в самом деле скажет: "дай мне список содержания папки, где я нахожусь сейчас".

Если Вы хотите перечислить содержание определенной папки, Вы должны написать имя папки (см. ниже). То же самое относится к команде **cal**. Печатая **cal**, Вы получаете календарь текущего месяца. Если Вы хотите знать, какой день недели началось новое тысячелетие, напишите **cal 2000**. Позже мы будем также посмотреть на команды с двумя объектами.

Команды могут также быть модифицированы. Программисты называют модификаторы команд вариантами или флагами. Различные команды принимают различные модификаторы или флаги, и значение флага варьируется от команды до команды. Флаги, как правило, состоят из одной буквы или числа, с предшествующим дефисом. Например, команда **cal** имеет флаги **-m** (m = Monday = понедельник) и **-3** (или любое иное число 1..12 - это порядковый номер месяца).
Если дать команду **cal** без флагов, первым днем недели в календари является воскресенья, а **cal -m10** выводит календарь октября текущего года, кроме того так, что неделя начинается с понедельника.

Резюме:

* Синтаксис команды: *команда* или *команда аргумент(ы)*  ENTER
* Команды: **date**, **cal**, **mkdir**

Команды могут быть замечены как глаголы в императиве. Эти глаголы могут быть непереходными или переходными (имеющие ни одного, одного или более одного аргументов), и они могут быть дополнены с модификаторами (флагами).

## Пейзаж Unix

Ваш корневой каталог расположен в другой папке. Это также содержит другие папки - корневые каталоги других пользователей. Структура системы папок можно сравнить с родословным деревом. Мать всех папок - корневой каталог системы. У корневого каталога есть свой собственный символ в Unix, а именно, **/**.

Чтобы видеть содержание корневого каталога, Вы можете напечатать **ls /**, т.е. "перечислять содержание корневого каталога". Не забудьте нажимать ENTER. Там Вы будете видеть некоторые загадочные имена - названия различных папок и файлов.

На системах Linux папку пользователей называют **home**. Соответствующюю папку на компьютерах Mac называют **Users**. Эта папка содержит личные папки всех пользователей на системе. Если Вы работаете над личным ноутбуком, Вы, вероятно, единственный пользователь. Команда **ls /home** или **ls /Users** перечисляет содержание папки. Одно из имен пользователя - Ваше.
Если Вы напишете просто **ls**, то Вы будете видеть все файлы и папки, которые Вы имеете в папке, где Вы находитесь прямо сейчас.

Резюме:

* корневой каталог (корневая папка)  **/**
* Структура каталогов: дерево. В графическом интерфейсе пользователя каталогов называют папками.
* Команда: **ls**

## Создание папок и перемещения в системе папок

Создайте папку для этого курса, давайте назовем его **unixcourse**. Таким образом, напишите **mkdir unixcourse**. Напишите **ls**, и Вы видите, что папка была создана. Если Вы тогда печатаете **ls unixcourse**, Вы можете узнать то, что в новой папке. Да, совершенно верно, ничто.

Тогда попытайтесь двинуться в папку. Напечатайте **cd unixcourse**. Проверьте, если приглашение (текст налево от курсора) измененилось. Если Вы тогда печатаете **ls unixcourse**, Вы получаете абсолютно различный ответ, чем предыдущий раз. Почему?

Причина того, что Вы теперь получаете ответ "нет такого файла или каталога" (или нечто подобное) состоит в том, что папка **unixcourse** не содержит папку, названную "unixcourse". Создайте теперь новую папку, например. **mkdir somename**. Вы можете тогда вернуться к своему корневому каталогу, печатая **cd ..** (**cd** пробел точка точка). Значение двух точек - "родительский каталог". Вы можете тогда напечатать **ls unixcourse** и получить ответ "somename".

Вы можете использовать символы **..** также в других контекстах. Команда **ls ..** означает, "перечислите содержание родительского каталога папки, где я нахожусь". Если Вы стоите в папке **unixcourse**, и Ваш корневой каталог содержит, например, папки **unixcourse** и **Documents**, Вы можете перечислить содержание Документов, печатая **ls ../Documents**. Точки (..) означают "один уровень вверх", и косая черта (/) означает "один уровень вниз". Имя **Documents** определяет, содержание какой папки нужно перечислить.

Одна папка более важна, чем все другие папки: Ваша корневая папка. Если Вы находитесь в папке **unixcourse** и хотите пойти домой, Вы могли бы написать **cd ..**. Но если Вы не уверены, где Вы, или Вы хотите сразу пойти домой, Вы можете написать только **cd**. Команда перемещает Вас в Вашу корневую папку.

Если Вы хотите узнать, где Вы, напишите **pwd** - это означает "print working directory" ("печатать рабочую папку"). В ответ Вы получите путь от корневой папки до папки, где Вы находитесь прямо сейчас.

Резюме:

Структура папок: родительская папка, рабочая папка, подпапка ...

Команды:
* **cd** (перемещает меня домой)
* **cd ..** (перемещает меня один уровень вверх в структуре папок)
* **pwd** (скажет, в какой папке я нахожусь)

## Относительная и абсолютная ссылка

В Unix-е есть два способа указать на файлы и папки  - с помощью абсолютной или относительной ссылки. До сих пор мы использовали относительные ссылки. Когда мы используем относительную ссылку, ссылка зависит от того, где мы стоим. Предположим, что Вы находитесь в корневой папке, и там есть подпапка, названная **unixcourse**. Тогда возможно написать **ls unixcourse**.
Но если Вы стоите в родственной папке Documents, это не возможно, тогда Вы должны написать **ls ../unixcourse**, чтобы видеть содержание. Относительная ссылка таким образом относительно того, где Вы в системе, когда Вы пишете команду.

Если Вы используете абсолютную ссылку, неважно где Вы стоите, потому что абсолютная ссылка показывает Вам, где файл или папка расположен, начиная с корневой папки (**/**). Если Ваше имя пользователя **trond**, то печатая **ls /Users/trond/unixcourses/** будет работать, независимо от того в какой папке Вы находитесь. Ссылка на папку **unixcourse** больше не относительная, но абсолютная, это дано относительно корневой папки.

Резюме:

* Относительная ссылка зависит от того, где Вы находитесь в системе папок.
* Абсолютная ссылка - полный путь от корневой папки (через все промежуточные уровни) до папки, которую Вы хотите указать. Абсолютная ссылка **не зависит** от того, где Вы находитесь в системе папок.

## Просмотр содержимого файлов

Пойдите в папку **unixcourse**, которую Вы только что создали. Если Вы не знаете, где Вы, тогда Вы можете сначала написать команду **cd**, и после того **cd unixcourse**. Вы можете создать несколько файлов. Позже мы будем создать файлы с редактором текста, теперь мы сделаем их немного более удобным способом - с командой **cat**. Напишите **cat > n-list**. Ответ - не обычное приглашение, а пустая строка. Напишите одно слово, например, **Jane**, и нажмите ENTER. Напишите другое имя, например, **John**, и нажмите ENTER.
Напишите еще немного имени, например, **Peter**, **Anne**, **Mark**, **Lena**, с ENTER после каждого имени. Наконец конец команду **Ctrl-d** (удержите клавишу **CTRL** и нажмите букву **d**). Теперь Вы должны видеть приглашение. Символ ">" в команде означает "послать продукцию предыдущей команды в файл, имя которого напишено после ">" символа." Эта команда таким образом создает текстовый файл "n-list".

Если Вы тогда печатаете **ls**, Вы видите, что у Вас есть файл, а именно, "n-list". Если Вы хотите знать, что находится в файле, Вы можете написать **cat n-list**. Команда **cat** тогда напечатает целое содержимое файла на экране.

Если бы список имен в файле был очень длинным, то Вы предпочли бы просмотреть его постранично. Чтобы добывать это, напишите **less n-list**. Вы можете двигаться вперед на следующую страницу, нажимая клавишу ENTER или пробел. Когда Вы приедете до конца файла, Вы видете слово END в конце вывода. Чтобы возвратиться к командной строке (Вы не должны просмотреть целый файл!), нажмите клавишу **q**.

Резюме:

Команды:
* **cat**, **cat > имя файла**, **less**
* Возвращаться к командной строке: **q**

## Команды для обработки содержимого файлов

**sort**

Мы используем содержимое файла **n-list** из предыдущей секции в качестве примера, чтобы изучить некоторые очень важные команды. Одна обыкновенная задача - сортировать строки в файле. Напишите **sort n-list**, и Вы получаете список имен, которые были в файле, в алфавитном порядке. (Более легкий способ, который дает тот же результат, состоит в том, что написать **sort n** и затем нажать **ТАБУЛАТОР**. Если *n-list* является единственным файлом в папке, имя которого начинает с **n** , то Unix заполнит имя файла для Вас.)

Команду **sort** можно модифицировать с флагами. Флаги написаны с начальным дефисом (-) и помещены между командой и аргументом. Вместо того, чтобы писать **sort n-list** , Вы можете написать **sort -r n-list**. Флаг **-r** означает "reverse" ("обратный"), и файл таким образом сортирован в обратном порядке.

Резюме:

* Команда: **sort** - алфавитная сортировка
* флаг **-r** - сортировка в обратном порядке

**grep**

Следующая центральная команда - **grep**. Это обозначает, "get regular expression" ("достать регулярное выражение"), и отфильтрует все строки, которые имеют заданного типа. Напишите **grep J n-list**, и Вы получите в ответ **Jane** и **John**. Напишите **grep a n-list**, и Вы получите в ответ **Jane** и **Lena** (но не **Anne**).
Чтобы искать более сложные выражения, используйте единственные или двойные кавычки. Команда __grep mii имя_файла**находит из текста на северосамском языке  как *mii* так и *huksemiid*. Чтобы искать *mii* только в начале слов, Вы можете написать**grep ' mii' имя_файла**. Чтобы только искать целое слово *mii*, пользуйте флаг**-w**(**grep -w mii имя_файла__).

Резюме:

* Команда: **grep** - отфильтровать строки
* кавычки для более сложные выражения
* флаг **-w** - искать целое слово

**rev**

Команда **rev** полностью обратит строку. Напишите **rev n-list** и посмотрите, что произошло.

Видели? Все имена теперь написаны обратно. Может быть, это сам по себе не очень интересно, но если мы объединяем **rev** с другими командами, оно будет очень полезно для нас.

Резюме:
* Команда: **rev**, обратная строка ('отец' становится 'цето')

## Объединение команд с знаком |

Символ **|** (вертикальная черта или труба или пайп) - один из главных символов в Unix. На Макинтоше труба найдена на **alt-7**, на других компьютерах, символ трубы может быть найден на клавише налево от номера 1 в левом верхнем углу или направо от LEFT SHIFT в левом нижнем углу клавиатуры. С помощью символа **|** мы объединяем команды, или скорее: мы посылаем продукцию (вывод) из первой команды, как ввод к следующему.

Мы теперь объединяем команды **rev** и **sort**, и мы делаем это следующим образом: **rev n-list | sort | rev**. Что произошло? Мы обратили имена в нашем файле, обратили список, и обратили имена назад к нормальному. Результат - список имен, с которого мы начали, сортированный по последней буквой.

Резюме:
Символ труба **|** берет продукцию от предыдущей команды и вводит к следующему.

**wc**

Давайте теперь расширим наш файл с некоторыми именами. Напишите **cat >> n-list** и нажмите ENTER. Вы получаете пустую строку. Напишите имена **Peter**, **Ben**, **Anne** и **Mark**, ENTER после каждого имена. Тогда нажмите **Ctrl-d**. Различие между символами > и >> - то, что в первом случае Вы создаете новый файл (или Вы переписываете старое), тогда как во втором случае, Вы добавляете новое содержимое к уже существующему файлу.

Это - ОЧЕНЬ ВАЖНОЕ различие. Если Вы работали долгое время с файлом и написали сотни строки текста, и просто хотите добавить пару слов в конец, используйте >>. Однако, если Вы забываете и пишете > вместо этого, все те сотни строки исчезли, и все, что остается - те два слова, которые Вы хотели бы добавить. Unix не знает милосердия. Вы не вернете те сотни строки. Так, будьте осторожны!

Теперь скажем, это сделано, и у Вас есть файл, который содержит девять имен. Как узнать количество имен в файле? Ответ: команда **wc** (количество слов). Напишите **wc n-list**, и Вы видите, сколько строк, слов и символов этот файл содержит. Если Вы только хотите видеть один из трех ответов, Вы можете сделать это с флагом **-l** (lines = строки), **-w** (words = слова) и **-c** (characters = символы, т.е. буквы, остальные знаки на клавиатуре, пробелы и.т.д.), например: **wc -l**. Флаги могут также быть объединены: **wc -lw** выводит, сколько строк и слов файл содержит.

Резюме:

* Команда: **wc**, выводит, сколько строк, слов и символов содержится в файле
Пометить: у команды **wc** есть флаги **-l**, **-w** и **-c** (строки, слова и символы)
* символ **>>**: Добавляет данные, которые Вы посылаете его, в конец файла.

**uniq**

В файле **n-list** некоторые из строк теперь идентичны. Напишите **sort n-list**, и Вы будете видеть это. Если Вы интересуетесь только тем, сколько различных строк есть в файле, а не повторениями, Вы можете напечатать `sort n-list | uniq`. Если Вы хотите знать количество повторении каждого имени, Вы можете добавить флаг **-c**, который обозначает "количество", к команде **uniq**: `sort n-list | uniq -c`. Более продвинутая команда - следующая (вычисляет количество повторений для каждого имена и сортирует список имен по количеству повторений):

`sort n-list | uniq -c |  sort -n`

Команда становится еще лучше с флагом **-nr**:

`sort n-list  | uniq -c |  sort -nr`

С этой командой мы создали "частотный словарь". Наиболее распространенные слова в начале, и уникальные в конце. Слова с той же самой частотой сортированы в алфавитном порядке.

**tr**

Команда **tr** заменяет одну букву (или любой символ) на другую. Эта команда отличается от других команд в том, что она не принимает имя файла в качестве аргумента. Чтобы изменить все буквы "e" на "x" в файле **n-list**, введите команду

`cat n-list  |  tr 'e' 'x'  |  less`

(Помните, что Вы оставляете программу **less**, нажимая **q**). Эта команда дает Вам результат на экране. Если Вы хотите сохранить результаты в файле, напишите

`cat n-list | tr 'e' 'x' > newfile`

Новый файл тогда сохранен как "newfile". Обратите внимание на то, что Вы не можете использовать имя исходного файла для файла результатов.

Мы можем также использовать команду **tr** для превращения текста в список (текстовый файл, в котором на каждой строке - одно слово). Чтобы достигнуть этого, мы заменяем все пробелы на символ новой строки, который записывается как **"\n"**. Мы также можем превращать список в текст:

```
cat n-list | tr '\n' ' '  > n-text
```

Если Вы тогда печатаете `cat n-text`, Вы видите, что имена теперь стоят в ряд на той же самой строке. Вы можете возвратиться к формату списка, повернув символы новой строки и пробела в команде и написать:

```
cat n-text | tr ' ' '\n'
```

## Творческая лень:  многократное использование той же самой команды

Очень скоро команды становятся длинными. Вместо того, чтобы печатать ту же самую команду снова и снова, Вы можете использовать клавиши-стрелки. Клавиша "стрелка вверх" дает Вам предыдущую команду. Чтобы выполнить его, Вы должны, очевидно, нажать клавишу ENTER. Нажатие на "стрелка вверх" еще раз дает Вам команду перед предыдущей.

Если Вы пишете **history**, Вы получаете список всех выполненных команд, которые Вы дали. Перед каждой команды есть число. Если Вы хотите, например, дать команду номер 55 снова, напишите !55, и та же самая команда будет выполнена снова.

Вы можете тоже редактировать команды (это особенно удобнее чем написать команду снова, если команда длинная). Давайте скажем, что Вы написали команду

`grep e n-list | rev | sort | rev `

Результатом был сортированный список всех имен, которые содержают **e**. Вы можете теперь нажать "стрелка вверх", получить предыдущую команду снова и нажать клавишу "стрелка влево", пока Вы не достигаете **e**. Вы тогда удаляете его и пишете **a** вместо этого, и после того Вы нажимаете ENTER. Результат - алфавитный словарь имен, содержащих гласную **a**.

Если команда длинная, то движение до начала с помощью стрелки занимает слишком много времени. Более быстрый способ добраться до начала - нажимать на **ctrl-a**. Чтобы возвратить до конца - нажмите **ctrl-e**.

Резюме:

* Клавиша "стрелка вверх" показывает Вашу предыдущую команду.
* С клавишами "стрелка влево" и "стрелка вправо" можно передвигаться в команде.
* **ctrl-a** перемещает курсор в начало команды.
* **ctrl-e** перемещает курсор в конец команды.
* **history** показывает список всех выполненных команды.
* **!123**, где 123 - число порядки команды в списке выполненных команд, дает ту же самую команду снова.

## Как копировать, переместить и переименовать файлы

Файлы можно копировать с командой **cp** (copy). Давайте скопируем файл **n-list** в новый файл, который Вы можете назвать **n-list2**. Для этого напишите `cp n-list n-list2`. Результат - два файла с тем же содержанием.

Чтобы дать файлу новое имя, используйте команду **mv** (move). Синтаксис - то же самое: __mv старое_имя новое_имя**. Имя**mv__ действительно означает движение, если мы вместо нового имя напишем имя некоторой папки.

Маленькая попытка:
Сначала создаем новую папку:

`mkdir oldfiles`

Тогда команда

`mv n-list2 oldfiles`

не превратит **n-list2** в файл, названный **oldfiles**. Вместо того команда переместит файл **n-list2** в папку **oldfiles**.

| ОСТОРОЖНО! Если Вы переименуете файл в имя, которое уже существует, то старый файл будет удален. У Unix нет кнопки отмены, таким образом, содержание старого файла будет потеряно.

## Регулярные выражения

Мы используем регулярные выражения, чтобы искать классы символов. Как испытательный документ Вы можете взять файл *eng_vaalit2012.txt* в каталоге [https://gtsvn.uit.no/langtech/trunk/courses/unix_korpus/]. Загрузите файл. Если Вы используете Mac и настроили папку как выше, и Вы стоите в папке **unixcourse**, Вы можете скопировать файл в папку **unixcourse** с командой

`cp ../Downloads/eng_vaalit2012.txt .`

Последная точка в команде значит: "Скопируйте файл туда, где я теперь". Отметьте пространство между именем файла и точкой.

Как пример мы берем два предложения (если Вы практикуете, Вы можете скопировать их в отдельный документ, который Вы можете назвать **td-list**).:
```
cat eng_vaalit2012.txt | tr ' ' '\n' | grep '^d'
cat eng_vaalit2012.txt | tr ' ' '\n' | grep 'd$'
cat eng_vaalit2012.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head
```

Здесь мы также ввели новую команду, **head**. Команда **head** выводит первые 10 строк из результата.

С помощью регулярных выражений мы можем получить различные наборы слов из текста. Следующие команды отфильтруют все слова, заканчивающиеся на `-ate`, на последовательности "**a** `любой символ` **e**" или на последовательности "**a** `любое число любых символов` **e**". Заключительная команда дает все слова, заканчивающиеся на **d**, которому предшествует любой символ кроме **e**.

```
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'ate$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.*e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '[^e]d$'
```

Возможно тоже искать классы звуков. Таким образом,
```
[aeiouy]
```
- класс всех гласных на английском языке. Этот поиск возвращает все слова, содержащие согласного **c** с последующим любым гласным:

```
grep 'c [aeiouy]' eng_vaalit2012.txt
```

Регулярные выражения могут быть объединены. Как записать все случаи **o** плюс любой символ плюс гласный?

```
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'o.*[aeiouy]'
```
Мы можем использовать скобки и для того, чтобы искать и заглавные и строчные буквы:

```
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^in'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^[Ii]n'
```

Если мы хотим искать несколько последовательностей, нам нужна расширенная команда **grep**, **egrep**.
Здесь поиск всех слов, заканчивающихся на **-ing** или **-ed**:

```
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|egrep' (ing|ed)$'
```

Больше информации о регулярных выражениях найдено на Википедии:
* [http://en .wikipedia.org/wiki/Regular_expression]
* [http://ru .wikipedia.org/wiki/Регулярные_выражения]

## Встроенная система справочной информации Unix: man, apropos и info

У Unix есть очень хорошая встроенная система справочной информации. Если Вы знаете название команды и хотите больше информации, Вы можете написать **man** и названию команды (например, `man grep`).

Есть две проблемы: Вы должны знать название команды, прежде чем Вы сможете спросить, и текст часто немного загадочный. Страницы **man** лучше всего подходят, если Вы хотите узнавать, какие флаги использовать с командой, и как они работают.

Чтобы получить более образовательный текст, Вы можете написать **info** вместо **man**. Если это тоже является слишком загадочным, Вы можете искать в Интернете. Чтобы получить объяснение на команду **cat**, Вы можете искать: Как использовать команду **cat**.

Если Вы не уверены в названии команды, которую Вы ищете, Вы можете написать **apropos** название команды (например, `apropos search`). **apropos** выводит Вам список названий команд, которые могли бы иметь некоторое отношение к слову (а возможно, нет!), которое Вы ввели. Обычно команда **apropos** не настолько полезна.

Список команд Unix:

* [http://en .wikipedia.org/wiki/List_of_Unix_utilities]
* [http://ru .wikipedia.org/wiki/Программы_UNIX-подобных_операционных_систем]
