<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN"
"http://forrest.apache.org/dtd/document-v20.dtd">
<document xml:lang="en">
  <header>
    <title>The VISL Constraint Grammer Parser "vislcg"</title>
  </header>

  <body>
    <section>
      <title>WARNING!</title>
<p>This documentation is obsolete, and for the time being kept as reference. We now use vislcg3 (cf. separate documentation)</p>
    </section>

    <section>
      <title>Introduction</title>

      <p>"vislcg" is a constraint grammar parser, i.e., it is a program that
      selects the correct analysis in case of homonymy. The idea behind
      constraint grammars dates back to Fred Karlsson, as does its first
      version, CG-1, programmed in Lisp, the vislcg version presented here is
      Eckhardt Bick's open source implementation of Pasi Tapanainen's CG-2
      (written in C). This document is taken from the downloadable vislcg
      version at sourceforge.</p>
    </section>

    <section>
      <title>The VISL Constraint Grammer Parser "vislcg"</title>

      <p>This document describes the similarities and differences between CG-2
      and the vislcg Constraint Grammar parser. It is not, in its current
      form, intended as an introduction, tutorial, or reference to the CG
      formalism. Please refer to [Tapanainen, 1996]</p>
    </section>

    <section>
      <title>Speed</title>

      <p>vislcg is not designed for speed but performs reasonably well. On a
      Pentium II class PC, it disambiguates at about 1600 words per second
      using a morphological disambiguation grammar for Danish with about 1000
      rules. This is about 16% the speed of CG-2 on the same platform, with
      the same rules and the same input.</p>
    </section>

    <section>
      <title>SGML tags and comments</title>

      <p>vislcg does not currently support SGML tags in the input stream.</p>

      <section>
        <title>Modules</title>

        <p>There are no separate parsers for different approaches or
        behaviors. The behavior of the vislcg parser is controlled by command
        line parameters (flags).</p>
      </section>

      <section>
        <title>Flags</title>

        <p>The command vislcg --help will list all supported parameters and
        flags, and a brief description of each:</p>

        <dl>
          <dt>--check-only</dt>

          <dd>Test the syntax of the rules file and exit before performing any
          mappings or disambiguations.</dd>

          <dt>--debug</dt>

          <dd>Run compiler in debug mode.</dd>

          <dt>--grammar=rulesfile or</dt>

          <dd></dd>

          <dt>--grammar rulesfile</dt>

          <dd>Specifies which rules file to use. This option must be specified
          if any parsing is to be done.</dd>

          <dt>--help</dt>

          <dd>Print this text.</dd>

          <dt>--minimal</dt>

          <dd>Equivalent to --verbosity=minimal</dd>

          <dt>--no-corrections</dt>

          <dd>Do not apply any correction rules.</dd>

          <dt>--no-mappings</dt>

          <dd>Do not apply any mapping rules. This corresponds to CG-2's dis
          module</dd>

          <dt>--prefix=marker or --prefix marker</dt>

          <dd>This changes the special marker for ambiguity and mappings. The
          marker may be more than one character. The default marker is the '@'
          character.</dd>

          <dt>--quiet</dt>

          <dd>Do not output any messages. This option overrides any debug and
          trace options.</dd>

          <dt>--reorder</dt>

          <dd>Attempt to reorder rules in a way similar to CG-2, using
          PREFERRED-TARGETS and rules of thumb. [ The default is to apply
          rules in the strict order they appear in the rules file and ignore
          PREFERRED-TARGETS ]</dd>

          <dt>--sections=n or --sections n</dt>

          <dd>This sets the number (n) of CONSTRAINT sections that are
          applied. The default is to apply all sections.</dd>

          <dt>--trace</dt>

          <dd>Equivalent to --trace-mappings --trace-constraints.</dd>

          <dt>--trace-constraints</dt>

          <dd>Trace which constraints were applied and the order of
          application.</dd>

          <dt>--trace-mappings</dt>

          <dd>Trace which mappings were applied and the order of
          application.</dd>

          <dt>--unsafe</dt>

          <dd>Allow the compiler to remove the last reading of a cohort.</dd>

          <dt>--verbose</dt>

          <dd>Equivalent to --verbosity=verbose</dd>

          <dt>--verbosity=level or --verbosity level</dt>

          <dd>This option causes extra or less information to be printed in
          trace mode. Valid levels are: <dl>
              <dt>'minimal'</dt>

              <dd>- Line numbers of applied rules are attached to the output
              cohorts. The output in minimal mode is similar to that of CG-2's
              mdis.trace module.</dd>

              <dt>'normal'</dt>

              <dd>- Instead of attaching line numbers to readings, each rule
              (the full specification - not just the line number) is printed
              each time it is applied. [ 'normal' is the DEFAULT trace mode
              verbosity.]</dd>

              <dt>'verbose'</dt>

              <dd>- As normal mode, but the cohort to which each rule was
              applied is printed as well. This will also cause vislcg to print
              all sets, mappings and constraints before processing any
              input.</dd>
            </dl></dd>
        </dl>
      </section>
    </section>

    <section>
      <title>Sections of the rule file</title>

      <p>The section headers are DELIMITERS, PREFERRED-TARGETS, SETS,
      CORRECTIONS, MAPPINGS, CONSTRAINTS, and END. The sections SETS,
      CORRECTIONS, MAPPINGS, and CONSTRAINTS may be repeated any number of
      times.</p>

      <p>The CORRECTIONS section is a vislcg-specific extension of the CG
      formalism. See section 2.1.5a. ans 2.5a. for details.</p>

      <p>The minimal set of sections in a rule file is:</p>

      <source>DELIMITERS
CONSTRAINTS

or

DELIMITERS
MAPPINGS

or

DELIMITERS
CORRECTIONS
</source>

      <section>
        <title>2.1.5a. Section: CORRECTIONS</title>

        <p>The correction rules handle lexical or other errors by substituting
        some tags with others in readings or appending new readings to
        cohorts. All corrections are applied after mappings, but before
        constraints.</p>

        <source>SUBSTITUTE
</source>

        <p>A SUBSTITUTE operation replaces tags with other tags in a
        reading.</p>

        <p>General form:</p>

        <p>"&lt;wordform&gt;" SUBSTITUTE (tag1 tag2 ...) (tag3 tag4 ...)
        TARGET (tag5 tag6 ...) IF (context1) (context2) ... ;</p>

        <p>The first list of tags (tag1 tag2 ...) is the list of tags to
        remove from the targetted reading. The second tag list (tag3 tag4 ...)
        is the list of tags to insert into the reading.</p>

        <p>If the contextual tests hold, any tag in the removal list that
        appears in the reading are deleted from the reading. Note that the
        tags in the removal list must be in the same order as those in the
        reading.</p>

        <p>The list of insertions is then inserted into the reading in place
        of the lastly removed tag. Note that the insertion will take place if
        just one of the tags in the removal list appeared in the reading.</p>

        <p>Often, the tags in the removal list should also appear in the
        target of the rule.</p>

        <source>APPEND
</source>

        <p>An APPEND operation adds an entire reading (a new line) - not just
        a sequence of tags as ADD and MAP operations do. No TARGET is used as
        APPEND does not address individual readings but an entire cohort (of
        readings).</p>

        <p>General form:</p>

        <p>"&lt;wordform&gt;" APPEND ("baseform" tag1 tag2) IF (context1)
        (context2) ... ;</p>

        <p>Examples</p>

        <source> # Remove the tags A and B from the target reading and insert the tag C.
 "&lt;something&gt;" SUBSTITUTE (A B) (C) TARGET (D) ;

 # Append the reading "another" A B C to cohorts with the wordform
 # " &lt;another&gt; " in the given context
 "&lt;another&gt;" APPEND ("another" A B C) IF (1 (D)) ;
</source>

        <p>Syntax</p>

        <p></p>

        <ul>
          <li>The keyword CORRECTIONS begins the section.</li>

          <li>A correction rule is a list of items separated by blanks. The
          items are: <ul>
              <li>For SUBSTITUTE <ol>
                  <li>an optional wordform,</li>

                  <li>the SUBSTITUTE keyword,</li>

                  <li>a removal tag list,</li>

                  <li>an insertion tag list,</li>

                  <li>an optional keyword TARGET,</li>

                  <li>a target tag (or set),</li>

                  <li>an optional keyword IF,</li>

                  <li>possibly several contextual tests.</li>
                </ol></li>

              <li>For APPEND <ol>
                  <li>an optional wordform,</li>

                  <li>the APPEND keyword,</li>

                  <li>an insertion tag list,</li>

                  <li>an optional keyword IF,</li>

                  <li>possibly several contextual tests.</li>
                </ol></li>
            </ul></li>

          <li>The list may extend over several lines.</li>

          <li>The correction rule is terminated by the semicolon ";".</li>

          <li>There may be several correction rules.</li>

          <li>Comments may be added anywhere. The number-sign "#" begins a
          comment which then continue to the end of the line.</li>
        </ul>
      </section>
    </section>

    <section>
      <title>Symbols</title>

      <section>
        <title>2.2.3 Positions</title>

        <p>vislcg supports all the position and search features of CG-2:</p>

        <p></p>

        <dl>
          <dt>Relative position:</dt>

          <dd>0 = same cohort.</dd>

          <dt></dt>

          <dd>1 = the next cohort to the right.</dd>

          <dt></dt>

          <dd>-2 = the second cohort to the left.</dd>

          <dt>Absolute position:</dt>

          <dd>@1 = the first cohort in the context.</dd>

          <dt></dt>

          <dd>@-2 = the second to last cohort in the context.</dd>

          <dt>Search:</dt>

          <dd>Continous search: (NOTE: see 2.4.5.2)</dd>

          <dt></dt>

          <dd>**1 = search right, handling links specially.</dd>

          <dt></dt>

          <dd>**-1 = search left, handling links specially.</dd>

          <dt></dt>

          <dd>**-2 = search left, starting from the second cohort to the left,
          handling links specially.</dd>

          <dt>Careful mode:</dt>

          <dd>Any position followed by the letter C will cause "careful"
          checking, i.e. every reading of the cohort has to belong to the
          given set. E.g.: (-1C (P)) will test whether all readings of the
          preceding cohort is P.</dd>
        </dl>
      </section>

      <section>
        <title>2.3.5. Set operations</title>

        <section>
          <title>2.3.5.3. Intersection of sets (_)</title>

          <p>SET I = S1 _ S2 ;</p>

          <p>The _ operation is subtly different from the way CG-2 behaves. In
          vislcg, the _ operator does not make the Cartesian product of the
          two operand sets, but instead asserts that to be a member of the set
          I, a reading must be a member of both S1 and S2. This means that the
          _ operation in vislcg is properly the intersection operation, not
          the Cartesian product or concatenation.</p>

          <p>Sets constructed using the _ operator in rules written for CG-2
          should behave identically when used in vislcg and CG-2.</p>

          <p>However, there may be subtle differences.</p>

          <p>E.g: In vislcg, the following two sets are equivalent:</p>

          <p>SET I1 = (A B) _ (C D) ;<br /> SET I2 = (C D) _ (A B) ;</p>

          <p>Because the _ operation is the intersection operation in vislcg,
          the following readings will all be members of both I1 and I2:</p>

          <source>        A B C D
    C D A B
    A C D B
</source>

          <p>[ Note the reading A C D B. It is a member because it matches
          both (A B) and (C D). A D C B wouldn't be a member; it matches (A B)
          but not (C D). ]</p>

          <p>In CG-2, because the _ operation is the concatenation operation,
          the two sets are not equivalent. Only the reading A B C D is a
          member of I1 and only C D A B is a member of I2.</p>

          <p></p>
        </section>

        <section>
          <title>2.3.5.4. Precedence</title>

          <p>Operator precedence for set operations are as described for
          CG-2:</p>

          <ol>
            <li>_ and - from left to right;</li>

            <li>OR.</li>
          </ol>

          <p></p>
        </section>
      </section>

      <section>
        <title>2.3.6. Ambiguity Class (AND)</title>

        <p>The ambiguity class operation (AND) is not supported by vislcg. To
        achieve the same effect that A AND N has in CG-2, use A LINK 0 N.</p>

        <p></p>
      </section>

      <section>
        <title>2.4.2. Operations</title>

        <p>The IFF operation is not supported.</p>
      </section>

      <section>
        <title>2.4.4. Contextual tests</title>

        <p>The handling of contextual tests is intended to be consistent with
        CG-2's behavior, but currently handles linked, careful, continous
        searches subtly different.</p>

        <p>Testing wordforms:</p>

        <p>Contextual test are tested against the wordforms of cohorts, too.
        Here, the wordform is interpreted as a reading with one tag: the
        wordform. E.g.: The test (1 ("&lt;$.&gt;")) will match a cohort which
        is a full stop.</p>

        <p></p>

        <section>
          <title>2.4.4.4. Same position</title>

          <p>It _is_ possible in vislcg to have more than one contextual test
          for each position, e.g. the tests (1 A) (1 B) are legal in the same
          rule. This is contrary to CG-2, and no warning will be given.</p>

          <p></p>
        </section>

        <section>
          <title>2.4.4.5. Complement</title>

          <p>In negated contextual tests, such as</p>

          <source>     (NOT context0 LINK context1 LINK context2)
</source>

          <p>the negation is applied last and the rule is interpreted as</p>

          <source>     ! (context0 &amp;&amp; (context1 &amp;&amp; context2)) /* C or Perl-like syntax */
</source>

          <p>[Tapanainen 1996; 2.4.5. page 33]: "Here, the negation is applied
          last".</p>

          <p>In negated LINKed contexts, such as</p>

          <source>     (context0 LINK NOT context1 LINK context2)
</source>

          <p>the negation is applied only to context1, not to "context1 LINK
          context2" I.e.: the LINK to context2 will only be tested if context0
          matches /and/ the linked context1 does not. The above context test
          is therefore interpreted as</p>

          <source>     context0 &amp;&amp; ( (!context1) &amp;&amp; context2)
</source>

          <p>Combining the two above cases, the contextual test</p>

          <source>     (NOT context0 LINK NOT context1 LINK context2)
</source>

          <p>is interpreted as</p>

          <source>     ! (context0 &amp;&amp; ( (!context1) &amp;&amp; context2))
</source>
        </section>
      </section>

      <section>
        <title>2.4.5. Linking</title>

        <p>Careful LINKs are supported, as well as the negated links mentioned
        above. E.g.:</p>

        <source>     (*1 VFIN LINK 0C P)
     The next cohort to the right which has a reading belonging to the set
     VFIN is unambigously P.
</source>

        <p>The above test is NOT equivalent to either</p>

        <source>     (*1C VFIN _ P)
     To the right, there is a cohort which is unambigously both VFIN and P.
</source>

        <p>or</p>

        <source>     (*1C VFIN LINK 0 P)
     The next cohort to the right which is unambigously VFIN
     also has a reading which is P.
</source>

        <p>or even (also with a careful link)</p>

        <source>     (*1C VFIN LINK 0C P)
     The next occurrence of unambigous VFIN to the right is also
     unambigously P.
</source>

        <p>LINKs may be both careful and negated. E.g.:</p>

        <source>     (*1 A LINK NOT 1C B)
     The next occurrence of A to the right is immidiately followed by a
     cohort which is not unambigously B.
</source>

        <section>
          <title>2.4.5.2. Continuous search</title>

          <p>Continuous search is subtly different from CG-2.</p>

          <p>E.g.:</p>

          <source>     (**1C A LINK 1 B)
     There is a cohort to the right which is unambigously A and
     followed by a cohort with a reading that is B.
</source>

          <p>This seems to be inconsistent with CG-2 [Tapanainen 1996, 2.4.5.
          p.33]: "In careful mode, scanning stops at the first occurrence of A
          where the linked tests hold, i.e. the rule means that the next
          occurrence of A followed by B is unambigously A."</p>

          <p>In vislcg, scanning will not stop at the first occurrence of A
          followed by B. In continous search, the LINK will never be tested
          unless the preceeding test (1C A) holds, even in careful mode.</p>

          <p>E.g.: In visl-cg, but not in CG-2, the following input should
          satisfy the above contextual test (the target of the rule being the
          reading of "&lt;0&gt;"):</p>

          <source>"&lt;0&gt;"
    X
"&lt;1&gt;"
    A
    X
"&lt;2&gt;"
    B
"&lt;3&gt;"
        A
    A
"&lt;4&gt;"
    B
</source>
        </section>
      </section>
    </section>

    <section>
      <title>Corrections</title>

      <p>A correction rule modifies the information in the readings. Most
      often, this will be used to recover lexical errors.</p>

      <section>
        <title>2.5a.1. Correction Operations</title>

        <p>There are two operations for correction rules.</p>

        <p>- The SUBSTITUTE operation removes specific tags from a reading and
        inserts new ones. A schematic SUBSTITUTE rule is</p>

        <source>     "&lt;WORDFORM&gt;" SUBSTITUTE (REMOVAL TAGS) (INSERTION TAGS) TARGET (TARGET)
     IF (TEST1) (TEST2) ... ;
</source>

        <p>The removal and insertion parts of a substitute rule are lists of
        tags. If the target reading has one or more of the removal tags, these
        will be removed from the reading and replaced by the insertion
        tags.</p>

        <p>- The APPEND operation appends a new reading to a cohort. A
        schematic APPEND rule is</p>

        <source>     "&lt;WORDFORM&gt;" APPEND (INSERTION TAGS) IF (TEST1) (TEST2) ... ;
</source>

        <p>The APPEND operation does not take a target because it operates on
        cohorts, not readings.</p>
      </section>
    </section>

    <section>
      <title>Rule order</title>

      <p>The rule, target, and application ordering is not the same as for
      CG-2.</p>

      <p>The --no-reordering flag may be set, forcing the parser to always
      apply rules in the order of appearance in the rule file.</p>

      <p>Currently, reordering is done using the following priority list:</p>

      <p></p>

      <ol>
        <li>SELECT before REMOVE.</li>

        <li>SELECT rules targetting more preferred tags before rules
        targetting less preferred targets.</li>

        <li>REMOVE rules targetting less preferred tags before rules
        targetting more preferred targets.</li>

        <li>By order of appearance in rule file.</li>
      </ol>

      <p>This ordering may change arbitrarily in future versions.</p>

      <p>[ A possible future rule ordering is:</p>

      <ol>
        <li>Wordform rules before tag/set targets.</li>

        <li>SELECT before REMOVE.</li>

        <li>Negated contexts (NOT) first</li>

        <li>"Simple" rules before "complex" rules.</li>

        <li>Local positions before searches.</li>

        <li>Careful rules first. ]</li>
      </ol>

      <section>
        <title>2.6.1. Section order</title>
      </section>

      <section>
        <title>2.6.2. Target order</title>
      </section>

      <section>
        <title>2.6.3. Order in the rule file</title>
      </section>

      <section>
        <title>2.6.4. Application order of cohorts</title>
      </section>
    </section>

    <section>
      <title>Debugging</title>
    </section>

    <section>
      <title>Debug Mode</title>

      <p>The debug mode of the vislcg parser is similar to that of CG-2: In
      debug mode, the VISLCG compiler will issue a warning for every reading
      featuring a &lt;Correct!&gt; that the rule file would have removed if
      not run in debug mode.</p>

      <p>To run the rule file debugging option, the --debug option is invoked
      together with the vislcg command and the --grammar option. The benchmark
      corpus has initially been tagged by a parser and subsequently evaluated
      by human annotators, who have added the critical tag &lt;Correct!&gt; to
      each reading that was judged to be accurately tagged. The tagged
      benchmark corpus is fed into the parser using the new rule file as a
      test grammar. The syntax of this command line hence stipulates the
      indication of the rule file and the benchmark corpus input file used as
      input to the rule file as indicated by the greater-than sign:</p>

      <p>vislcg --grammar rulefilename --debug &lt; benchmarkcorpusname</p>

      <p>This corresponds to piping the corpus into vislcg by using the "cat"
      command:</p>

      <p>cat benchmarkcorpusname | vislcg --grammar rulefilename --debug</p>

      <p>You can debug a rule file (e.g. sandbox.txt) with IT Centre's
      benchmark corpus by typing:</p>

      <p>vislcg --grammar /home/cg-group/ sandbox.txt --debug &lt;
      /home/cg-group/bs-benchmark</p>

      <p>or</p>

      <p>cat /home/cg-group/bs-benchmark | vislcg --grammar /home/cg-group/
      sandbox.txt --debug</p>

      <p></p>
    </section>

    <section>
      <title>Bibliography:</title>

      <p>[Tapanainen, 1996]: Pasi Tapanainen. The Constraint Grammar parser
      CG-2. Publications of the Department of General Linguistics, University
      of Helsinki, no. 27. 1996. ISBN 951-45-7331-5</p>

      <p></p>

      <p>http://visl.sdc.dk</p>
      
    </section>
  </body>
</document>