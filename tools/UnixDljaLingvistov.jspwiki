Unix для лингвистов

Введение

Некоторые команды ОС Unix являются очень полезными инструментами для лингвистов - они способны обрабатывать объёмные массивы текстов быстро и эффективно. Чтобы быть в состоянии использовать эти команды, мы должны использовать интерфейс командной строки Unix. Это - краткое введение в Unix. После каждой секции маленькое резюме.

Команды Unix также найдены на Linux и на Mac OS X. Программа, которую мы используем, чтобы дать команды, обычно называют Терминалом ({{{terminal}}} или {{{xterm}}}). На MS Windows нет никакого Unix. Вы можете установить виртуальную машину Linux на Ваш Windows-компьютер. Альтернативно, Вы должны иметь пользовательский аккаунт (учетная запись) на другом компьютере с системой Unix. Вы можете войти в этот компьютер и использовать экран и клавиатуру на Вашей Windows-машине. Чтобы войти в другой компьютер, Вы можете, например, использовать программу putty.exe.

Чтобы использовать Unix на Mac или Linux нужно просто запустить приложение  {{{Terminal}}} (Терминал). На Mac это расположено в папке программ, в подпапке {{{Utilities}}} (Утилиты). В Linux терминал-программа обычно находится в папке помощных программ. Мы теперь предполагаем, что у Вас есть доступ к Unix на Вашей собственной машине.


Основные команды


Команды, не щелчок мыши

Unix отличается от большинства других операционных систем в том, что у него нет графического интерфейса пользователя. Вместо того Unix имеет то, что мы называем командной строкой, т.е. курсор стоит и ждет, чтобы Вы вводили команду. Прямо после того, как Вы открыли окно терминал-программы (и вошли в свою учетную запись, если надо), Вы находитесь в своем корневом каталоге. Налево от курсора есть короткий текст (приглашение), который говорит Вам, в каком папке Вы находитесь. 

Вы теперь изучите много команд. Команды должны быть написаны определенным способом. У команды Unix есть две обязательных части: команда должна начаться с названия программы, и команда закончена, когда Вы нажимаете клавишу ENTER. 

* Мы пробуем простую команду: 
** Напишите __date__ и нажмитe ENTER. 
** В ответ Вы должны получить текущий день недели, дату и время. 
* Другая команда: 
** Напишите __cal__ и нажмите ENTER. 
** Ответ - маленький календарь. 

С этого момента мы предположим, что Вы всегда нажимаете ENTER после команды. Поэтому "пишите __ls__" означает "пишите __ls__, и нажмите ENTER", и так же для других команд.

Большинство команд берет один или несколько аргументов. Одна такая команда - __mkdir__, что означает, "делайте папку" или создаёте папку. Попробуйте его: Напишите __mkdir__, нажмите ENTER, и Вы получите логический ответ. Чтобы заставить папку нуждается по крайней мере один аргумент - имя папки. Напишите например __mkdir hogwash__. Чтобы видеть, что произошло, напишите __ls__ (перечислите содержание папки, в которой Вы находитесь). Папку, которую Вы только что сделали, можете теперь удалить с помощью команд __rmdir hogwash__. Попробуйте команду __rmdir__, и затем попробуйте ей снова. (Команда __rmdir__ работает только с пустыми папками.)

С лингвистической точки зрения мы можем смотреть на команды как на глаголы. Так как все команды представляют наши запросы компьютеру, мы можем рассмотреть их как глаголы в императиве. Как другие глаголы так и Unix команды могуть быть переходными или непереходными. Например команда __date__ - как непереходный глагол: Вы пишете __date__, и машина говорит Вам, какое сегодня число и день недели. Команда __mkdir__, однако, является переходным глаголом, у нее должен быть объект (компьютерный термин для объекта: аргумент), а именно, название новой папки, которую Вы хотите создать.

Таким же образом как регулярные глаголы, команды Unix также работают с неявными объектамм. Интерпретация зависит от контекста. Если мы скажем "ещь!" мы обычно имеем в виду, "Ещь еду, которая находится перед тобой". У команды Unix __ls__ также есть такой контекстно-зависимый, неявный объект. Команда __ls__ в самом деле скажет: "дай мне список содержания папки, где я нахожусь сейчас". Если Вы хотите перечислить содержание определенной папки, Вы должны написать имя папки (см. ниже). То же самое относится к команде __cal__. Печатая __cal__, Вы получаете календарь текущего месяца. Если Вы хотите знать, какой день недели началось новое тысячелетие, напишите __cal 2000__. Позже мы будем также посмотреть на команды с двумя объектами.


Команды могут также быть модифицированы. Программисты называют модификаторы команд вариантами или флагами. Различные команды берут различные модификаторы или флаги, и значение флага варьируется от команды до команды. Флаги, как правило, состоят из одной буквы или числа, с предшествующим дефисом. Например, команда __cal__ имеет флаги __-m__ (m = Monday = понедельник) и __-3__ (или любое иное число 1..12 - это порядковый номер месяца). Если дать команду __cal__ без флагов, первым днем недели в календари является воскресенья, а __cal -m10__ выводит календарь октября текущего года и так, что неделя начинается с понедельника. 

Резюме:

* Синтаксис команды: ''команда'' или ''команда аргумент(ы)'' ENTER
* Команды: __date__, __cal__, __mkdir__

Команды могут быть замечены как глаголы в императиве. Эти глаголы могут быть непереходными или переходными (имеющие ни одного, одного или более одного аргументов), и они могут быть дополнены с модификаторами (флагами).

Пейзаж Unix

Ваш корневой каталог расположен в другой папке. Это также содержит другие папки - корневые каталоги других пользователей. Структура системы папок можно сравнить с родословным деревом. Мать всех папок - корневой каталог системы. У корневого каталога есть свой собственный символ в Unix, а именно, __/__. Чтобы видеть содержание корневого каталога, Вы можете напечатать __ls /__, т.е. "перечислять содержание корневого каталога". Не забудьте нажимать ENTER. Там Вы будете видеть некоторые загадочные имена - названия различных папок и файлов.

На системах Linux папку пользователей называют __home__. Соответствующюю папку на компьютерах Mac называют __Users__. Эта папка содержит личные папки всех пользователей на системе. Если Вы работаете над личным ноутбуком, Вы - вероятно, единственный пользователь. Команда __ls /home__ или __ls /Users__ перечисляет содержание папки. Одно из имен пользователя - Ваше. Если Вы напишете просто __ls__, то Вы будете видеть все файлы и папки, которые Вы имеете в папке, где Вы находитесь прямо сейчас.


Резюме:

* корневой каталог (корневая папка)  (/)
* Структура каталогов: дерево. В графическом интерфейсе пользователя каталогов называют папкамию
* Команды: __ls__, ls


Создание папок и перемещения в системе папок

Создайте папку для этого курса, давайте назовем его __unixcourse__. Таким образом, напишите __mkdir unixcourse__. Напишите __ls__, и Вы видите, что папка была создана. Если Вы тогда печатаете __ls unixcourse__, Вы можете узнать то, что в новой папке. Да, совершенно верно, ничто.

Тогда попытайтесь двинуться в папку. Напечатайте __cd unixcourse__ (папка изменения "средств __cd__"). Проверьте если приглашение (текст налево от курсора) измененилось. Если Вы тогда печатаете __ls unixcourse__, Вы получаете абсолютно различный ответ, чем предыдущий раз. Почему?

Причина того, что Вы теперь получаете ответ "нет такого файла или каталога" (или нечто подобное) состоит в том, что папка __unixcourse__ не содержит папку, названного "unixcourse". Создайте теперь новую папку, например. __mkdir somename__. Вы можете тогда вернуться к своему корневому каталогу, печатая __cd ..__ (__cd__ пробел точка точка). Значение двух точек - "родительский каталог". Вы можете тогда напечатать __ls unixcourse__ и получить ответ "somename"). Вы можете использовать символы __..__ также в других контекстах. Команда __ls ..__ означает, "перечислите содержание родительского каталога папки, где я нахожусь". Если Вы стоите в папке __unixcourse__, и Ваш корневой каталог содержит, например, папки __unixcourse__ и __documents__, Вы можете перечислить содержание Документов, печатая __ls ../documents__. Точки (..) означают "один уровень вверх", и косая черта (/) означает "один уровень вниз". Имя __documents__ определяет, содержание какой папки нужно перечислить.


Одна папка более важна, чем все другие папки: Ваша корневая папка. Если Вы находитесь в папке __unixcourse__ и хотите пойти домой, Вы могли бы написать __cd ..__ Но если Вы не уверены, где Вы, или Вы хотите сразу пойти домой, Вы можете написать только __cd__. Команда перемещает Вас в корневую папку.

Если Вы хотите узнать где Вы, напишите __pwd__ - это означает "печатать рабочую папку". В ответ Вы получите путь от корневой папки до папки, где Вы находитесь прямо сейчас.


Резюме:

Структура папок: родительская папка, рабочая папка, подпапка ...

Команды: 
* __cd__ (перемещает меня домой), 
* __cd ..__ (перемещает меня один уровень вверх в структуре папок), 
* __pwd__ (скажет в какой папке я нахожусь)

Относительная и абсолютная ссылка

В Unix-е есть два способа указать на файлы и папки  - с помощью абсолютной или относительной ссылки. До сих пор мы использовали относительные ссылки. Когда мы используем относительную ссылку, ссылка зависит от того, где мы стоим. Предположим, что Вы находитесь в корневой папке, и там есть подпапка, названная __unixcourse__. Тогда возможно написать __ls unixcourse__. Но если Вы стоите в родственной папке Documents, это не возможно, тогда Вы должны написать __ls ../unixcourse__, чтобы видеть содержание. Относительная ссылка таким образом относительно того, где Вы в системе, когда Вы пишете команду. 

Если Вы используете абсолютную ссылку, неважно где Вы стоите, потому что абсолютная ссылка показывает Вам, где файл или папка расположен, начиная с корневой папки (__/__). Если Ваше имя пользователя __trond__, то печатая __ls /Users/trond/unixcourses/__ будет работать, независимо от того в какой папке Вы находитесь. Ссылка на папку __unixcourse__ больше не относительная, но абсолютная, это дано относительно корневой папки.



Резюме:

* Относительная ссылка зависит от того, где Вы находитесь в системе папок.
* Абсолютная ссылка - полный путь от корневой папки (через все промежуточные уровни) до папки, которую Вы хотите указать. Абсолютная ссылка __не зависит__ от того, где Вы находитесь в системе папок.


Просмотр содержимого файлов

Пойдите в папку __unixcourse__, которую Вы только что создали. Если Вы не знаете, где Вы, тогда Вы можете сначала написать команду __cd__, и после того __cd unixcourse__. Вы можете создать несколько файлов. Позже мы будем создать файлы с редактором текста, теперь мы сделаем их немного более удобным способом - с командой __cat__. Напишите __cat > n-list__. Ответ - не обычное приглашение, а пустая строка. Напишите одно слово, например, __Jane__, и нажмите ENTER. Напишите другое имя, например, __John__, и нажмите ENTER. Напишите еще немного имени, например, __Peter__, __Anne__, __Mark__, __Lena__, с ENTER после каждого имени. Наконец конец команду __Ctrl-d__ (удержите клавишу __CTRL__ и нажмите букву __d__). Теперь Вы должны видеть приглашение. Символ ">" в команде означает "послать продукцию предыдущей команды в файл, имя которого напишено после ">" символа. Эта команда таким образом создает текстовый файл "n-list".

Если Вы тогда печатаете __ls__, Вы видите, что у Вас есть файл, а именно, "n-list". Если Вы хотите знать, что находится в файле, Вы можете написать __cat n-list__. Команда __cat__ тогда напечатает целое содержимое файла на экране.

Если бы список имен в файле был очень длинным, то Вы предпочли бы просмотреть его постранично. Чтобы добывать это, напишите __less n-list__. Вы можете двигаться вперед на следующую страницу, нажимая клавишу ENTER или пробел. Когда Вы приедете до конца файла, Вы видете слово END в конце вывода. Чтобы возвратиться к командной строке (Вы не должны просмотреть целый файл!), нажмите клавишу __q__.

Резюме:

Команды: 
* __cat__, __cat > имя файла__, __less__
* Возвращаться к командной строке: __q__


Команды для обработки содержимого файлов

__sort__

Мы используем содержимое файла __n-list__ из предыдущей секции в качестве примера, чтобы изучить некоторые очень важные команды. Одна обыкновенная задача - сортировать строки в файле. Напишите __sort n-list__, и Вы получаете список имен, которые были в файле, в алфавитном порядке. (Более легкий способ, который дает тот же результат, состоит в том, что написать __sort n__ и затем нажать __ТАБУЛАТОР__. Если ''n-list'' является единственным файлом в папке, имя которого начинает с __n__ , то Unix заполнит имя файла для Вас.)

Команду __sort__ можно модифицировать с флагами. Флаги написаны с начальным дефисом (-) и помещены между командой и аргументом. Вместо того, чтобы писать __sort n-list__ Вы можете написать __sort -r n-list__. Флаг __-r__ означает "reverse" ("обратный"), и файл таким образом сортирован в обратном порядке.


Резюме:

* Команда: __sort__ - алфавитная сортировка
* флаг __-r__ - сортировка в обратной порядке

__grep__

Следующая центральная команда - __grep__. Это обозначает, "get regular expression" ("достать регулярное выражение"), и отфильтрует все строки, которые имеют заданного типа. Напишите __grep J n-list__, и Вы получите в ответ __Jane__ и __John__. Напишите __grep a n-list__, и Вы получите в ответ __Jane__ и __Lena__ (но не __Anne__!).

Чтобы искать более сложные выражения, используйте единственные или двойные кавычки. Команда __grep mii имя_файла__ находит из текста на северосамском языке  как 'mii' так и 'huksemiid'. Чтобы искать __mii__ только в начале слов, Вы можете написать __grep ' mii' имя_файла__. Чтобы только искать целое слово 'mii', пользуйте флаг __-w__ (__grep -w mii имя_файла__).

Резюме:

* Команда: __grep__ - отфильтрировать строки
* кавычки '' для более сложные выражения
* флаг __-w__ - искать целое слово

__rev__

Команда __rev__ полностью обратит строку. Напишите __rev n-list__ и посмотрите, что произошло.

Видели? Все имена теперь написаны обратно. Может быть, это сам по себе не очень интересно, но если мы объединяем __rev__ с другими командами, оно будет очень полезно для нас.


Резюме:
* Команда: __rev__, обратная строка ('отец' становится 'цето')

Объединение команд с __|__

Характер __|__ или труба, один из главных символов в Unix. На Макинтоше труба найдена на __alt-7__ на других компьютерах, символ трубы может быть найден на ключе налево от номера 1 в левом верхнем углу клавиатуры. С | мы объединяем многократные команды, или скорее: мы посылаем продукцию из первой команды, как введено к следующему. Мы теперь объединим оборот команд и вид, и мы делаем это следующим образом: __rev n-list | sort | rev__. Что произошло? Мы полностью изменили имена в нашем файле, обратным списком, и повернулись назад к нормальному, оставленному более высокому тексту. Результат - сортированный список перемены имен, с которыми мы начали.



Резюме:
Символ трубы __|__ берет продукцию от предыдущей команды, как введено к следующему.

__wc__

Давайте теперь расширим наш файл с некоторыми другими именами. Напишите __cat >> n-list__ и нажмите ENTER. Вы получаете пустую строку. Напишите имена __Peter__, __Ben__, __Anne__ и __Mark__, все с ENTER между ними. Тогда нажмите __Ctrl-d__. Различие между символами > и >> - то, что в первом случае Вы создаете новый файл (или Вы переписываете старое), тогда как во втором случае, Вы добавляете новое содержание к уже существующему файлу. Это - очень важное различие. Если Вы работали долгое время с файлом и написали сотни линий текста, и просто хотите добавить слово или два в конце, используйте >>. Однако, если Вы забываете и пишете > вместо этого, все те сотни линий исчезли, и все, что возвращено, два плохих слова, которые Вы хотели бы добавить. Unix не знает милосердия. Вы не вернете те сотни линий. Так будьте осторожны.

Теперь скажем, это все подходит, и у Вас есть файл, который содержит в общей сложности девять имен. Как Вы знаете, что есть 9? Команда __wc__ (количество слов). Напишите __wc n-list__, и Вы видите, сколько линий, слов и изображает файл, содержит. Если Вы только хотите видеть один из трех ответов, Вы можете сделать это с флагом __-l__, __-w__ и __-c__, следующим образом: __wc -l__. Флаги могут также быть объединены: __wc -lw__ говорит, сколько линий и слов файл содержит.



Резюме:


Резюме:

* Команда: __wc__, говорит, сколько линий, слов и знаков там находится в файле
Пометить: у команды __wc__ есть флаги __-l__, __-w__ и __-c__ (линии, слова и знаки)
* символ __>>__: Добавляет содержание до конца файла, в который Вы посылаете его

__uniq__

В файле __n-list__ несколько из линий теперь идентичны. Напишите __sort n-list__, и Вы будете видеть его. Если Вы интересуетесь только тем, сколько различных линий Вы имеете, а не повторениями, Вы можете напечатать __sort n-list | uniq__. Если Вам интересно, в том, сколько есть каждого имени, Вы можете добавить флаг __-c__, который обозначает "количество" к команде __uniq: sort n-list | uniq -c__. Более продвинутая команда - следующий, который виды согласно числу пунктов:

__sort n-list | uniq -c | sort -n__

Команда становится еще лучше с выбором __-nr__:

__sort n-list | uniq -c | sort -nr__

С этой командой мы сортировали список частотой. Наиболее распространенные слова на первом месте, и уникальные в конце. Слова с той же самой частотой сортированы в алфавитном порядке.


__tr__

Команда __tr__ изменяет характер на другого. Эта команда отличается от других команд, не беря имена файла в качестве аргумента. Чтобы изменить все письма "e" на "x" в файле __n-list__, войдите в команду

__cat n-list | tr 'e' 'x' | less__

(Помните, что Вы оставляете программу меньше, нажимая __q__). Эта команда дает Вам результат на экране. Если Вы хотите спасти результаты к новому типу файла вместо этого, Вы можете напечатать 

__cat n-list | tr 'e' 'x' > newfile__

Новый файл тогда сохранен как "newfile". Обратите внимание на то, что Вы не можете использовать то же самое имя на файле назначения и исходном файле.



Очень полезная команда __tr__ - та, которая превращает текст в список с одним словом за линию. Чтобы достигнуть этого, мы заменим все места newline характером. newline характер мы пишем как '\n'. Начиная с какого мы имеем, список, мы начинаем, превращая его в текст:

__cat n-list | tr '\n' ' ' > n-text__

Если Вы тогда печатаете __cat n-text__, Вы, wil видят, что имена перечисляют, находятся теперь на той же самой линии. Вы можете возвратиться к формату списка, повернув команду и написать:

__cat n-текст | tr ' ' '\n'__



Творческая лень: многократное использование той же самой команды

Очень скоро команды становятся длинными. Вместо того, чтобы печатать ту же самую команду снова и снова, Вы можете использовать клавиши курсора. Ключ Стрела дает Вам предыдущую команду. Чтобы выполнить его, Вы должны, очевидно, нажать клавишу ENTER). Стрела еще раз дает Вам команду перед предыдущей.

Если Вы тогда пишете историю, Вы получаете список всех команд, которые Вы сделали. У каждой команды есть число. Если Вы хотите сделать, например, команду номер 55 снова, напишите! 55, и та же самая команда выполнен снова.

Длинные команды могут также быть, редактируют. Давайте скажем, что Вы написали команду

__grep e n-list | rev | sort | rev __


Результатом был сортированный список перемены всех имен, который содержит __e__. Вы можете теперь нажать Стрела, получить команду снова и нажать клавишу "влево", пока Вы не достигаете __e__. Вы тогда удаляете его и пишете __a__ вместо этого, и после того Вы нажимаете ENTER. Результат - сортированный глоссарий перемены всех имен, содержащих гласный __a__.

Если команда длинна, она может занять время, чтобы добраться до начала. Более быстрый способ добраться там нажимает __ctrl-a__. Чтобы возвратить до конца Вас нажимают __ctrl-e__.


Резюме:

история показывает предыдущие команды
__ctrl-a__, __ctrl-e__
Восклицательный знак плюс число правила дает ту же самую команду снова.



Копия, переместите и переименуйте файлы

Файлы скопированы с командой __cp__ (для "скопируй"). Скопировать файл __n-list__ к новому файлу, который Вы можете назвать __n-list2__, напишете __cp n-list n-list2__. Команда - таким образом "cp от к". Чтобы дать файлу новое имя, используйте команду __mv__ (движение). Синтаксис - то же самое: старое название __mv новое_имя__. Имя __mv__ действительно означает движение. Попытка, сначала делающая новую папку: 

__mkdir oldfiles__

Тогда команда:

__mv n-list2 oldfiles__

не превратит __n-list2__ в файл, названный __oldfiles__. Вместо этого это переместит файл __n-list2__ в папку __oldfiles__.

ПРЕДУПРЕЖДЕНИЕ: Если Вы переименуете файл к имени файла уже в использовании, то старый файл будет удален. У Unix нет кнопки сожаления, таким образом, содержание старого файла будет потеряно.


Регулярные выражения



Мы используем регулярные выражения, чтобы искать классы знаков. Как испытательный документ Вы можете взять файл ''eng_vaalit2012.txt'' в каталоге [https://victorio.uit.no/langtech/trunk/courses/unix_korpus/]. Загрузите файл. Если Вы используете Mac, и настроил папку как выше, и Вы стоите в папке __unixcourse__, Вы можете скопировать файл к папке __unixcourse__ с командой

__cp ../Downloads/eng_vaalit2012.txt .__

В команде, заключительных точечных средствах: "Скопируйте файл туда, где я теперь". Отметьте пространство между именем файла и точкой.

К глухому 'реле' последовательности в тексте, названном списком, мы написали список реле власти. Как пример мы берем эти два предложения (если Вы практикуете, Вы можете скопировать их к отдельному документу, который Вы можете назвать списком __td__).:


{{{
cat eng_vaalit2012.txt | tr ' ' '\n' | grep '^d'
cat eng_vaalit2012.txt | tr ' ' '\n' | grep 'd$'
cat eng_vaalit2012.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head
}}}

Здесь мы также ввели новую команду, __head__. Команда __head__ печатает первые 10 линий продукции.

Посредством регулярных выражений мы можем получить различные наборы слов из текста. Три после команд сдаются, все окончание слов - поело, закончив в последовательности {{любой характер __e__}}, в последовательности {{любое число знаков __e__}}. Заключительная команда дает все слова, заканчивающиеся в __d__, которому предшествует характер кроме __e__.

{{{
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'ate$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.*e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '[^e]d$'
}}}



Также возможно искать классы звуков. Таким образом [aeiouy] - класс всех гласных на английском языке. Этот поиск возвращает все слова, содержащие согласный __c__ плюс гласный:

__grep 'c [aeiouy]' eng_vaalit2012.txt__


Могут быть объединены все регулярные выражения. Как делают мы представляем все случаи __o__ плюс любой характер плюс гласный:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'o.*[aeiouy]'__

Скобки могут также использоваться, чтобы искать и заглавные и строчные буквы:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^in'__
__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^[Ii]n'__


Если мы хотим искать несколько последовательностей, нам нужна расширенная команда __grep__, __egrep__.
Здесь прибывает все слова, заканчивающиеся в __-ing__ или __-ed__.

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|egrep' (ing|ed)$'__



Больше информации о регулярных выражениях найдено на Википедию:
* [http://en .wikipedia.org/wiki/Regular_expression]
* [http://ru .wikipedia.org/wiki/Регулярные_выражения]


Встроенная система справочной информации Unix: __man__, __apropos__ и __info__

У Unix есть очень хорошая встроенная система справочной информации. Если Вы знаете название команды и хотите больше информации, Вы можете написать __man__ и названию команды (например, __man grep__). 

Есть две проблемы с этой информацией: Вы должны знать название команды, прежде чем Вы сможете спросить, и текст часто немного загадочный. Страницы __man__ больше всего подходят узнавать, какие флаги использовать с командой, и как они работают.

Чтобы получить более образовательный текст, Вы можете написать __info__ вместо __man__. Если также, который является слишком загадочным, Вы можете искать в сети. Чтобы получить объяснение на команду __cat__, Вы можете искать: Как использовать команду __cat__.

Если Вы не уверены в команде, Вы ищете, Вы можете написать __apropos__ название команды (для названия команды, Вы думаете возможно, что Вы ищете). Тогда __apropos__ даст Вам список названий команды, которые могли бы иметь некоторое отношение к нему (и возможно нет!). Обычно 'apropos' команда не настолько полезна.





Список команд Unix:

* [http://en .wikipedia.org/wiki/List_of_Unix_utilities]
* [http://ru .wikipedia.org/wiki/Программы_UNIX-подобных_операционных_систем]
