!!!Unix для лингвистов

!!Введение

Некоторые команды ОС Unix являются очень полезными инструментами для лингвистов - они способны обрабатывать объёмные массивы текстов быстро и эффективно. Чтобы быть в состоянии использовать эти команды, мы должны использовать интерфейс командной строки Unix. Это - краткое введение в Unix. После каждой секции маленькое резюме.

Команды Unix также найдены на Linux и на Mac OS X. Программа, которую мы используем, чтобы дать команды, обычно называют Терминалом ({{terminal}} или {{xterm}}). На MS Windows нет никакого Unix. Вы можете установить виртуальную машину Linux на Ваш Windows-компьютер. 

Альтернативно, Вы должны иметь пользовательский аккаунт (учетная запись) на другом компьютере с системой Unix. Вы можете войти в этот компьютер и использовать экран и клавиатуру на Вашей Windows-машине. Чтобы войти в другой компьютер, Вы можете, например, использовать программу putty.exe.

Чтобы использовать Unix на Mac или Linux нужно просто запустить приложение  {{Terminal}} (Терминал). На Mac это расположено в папке программ, в подпапке {{Utilities}} (Утилиты). В Linux терминал-программа обычно находится в папке помощных программ. Мы теперь предполагаем, что у Вас есть доступ к Unix на Вашей собственной машине.


!!Основные команды

!!Команды, не щелчок мыши

Unix отличается от большинства других операционных систем в том, что у него нет графического интерфейса пользователя. Вместо того Unix имеет то, что мы называем командной строкой, т.е. курсор стоит и ждет, чтобы Вы вводили команду. 

Прямо после того, как Вы открыли окно терминал-программы (и вошли в свою учетную запись, если надо), Вы находитесь в своем корневом каталоге. Налево от курсора есть короткий текст (приглашение), который говорит Вам, в каком папке Вы находитесь. 

Вы теперь изучите много команд. Команды должны быть написаны определенным способом. У команды Unix есть две обязательных части: команда должна начаться с названия программы, и команда закончена, когда Вы нажимаете клавишу ENTER. 

* Мы пробуем простую команду: 
** Напишите __date__ и нажмитe ENTER. 
** В ответ Вы должны получить текущий день недели, дату и время. 
* Другая команда: 
** Напишите __cal__ и нажмите ENTER. 
** Ответ - маленький календарь. 

С этого момента мы предположим, что Вы всегда нажимаете ENTER после команды. Поэтому "пишите __ls__" означает "пишите __ls__, и нажмите ENTER", и так же для других команд.

Большинство команд принимает один или несколько аргументов. Одна такая команда - __mkdir__, что означает, "делайте папку" или "создайте папку". Попробуйте его: Напишите __mkdir__, нажмите ENTER, и Вы получите логический ответ. Чтобы заставить папку нуждается по крайней мере один аргумент - имя папки. Напишите например __mkdir hogwash__. 

Чтобы видеть, что произошло, напишите __ls__ (перечислите содержание папки, в которой Вы находитесь). Папку, которую Вы только что сделали, можете теперь удалить с помощью команд __rmdir hogwash__. Попробуйте команду __rmdir__, и затем попробуйте ее снова. (Команда __rmdir__ работает только с пустыми папками.)

С лингвистической точки зрения мы можем смотреть на команды как на глаголы. Так как все команды представляют наши запросы компьютеру, мы можем рассмотреть их как глаголы в императиве. Как другие глаголы так и Unix команды могуть быть переходными или непереходными. Например команда __date__ - как непереходный глагол: Вы пишете __date__, и машина говорит Вам, какое сегодня число и день недели. 

Команда __mkdir__, однако, является переходным глаголом, у нее должен быть объект (компьютерный термин для объекта: аргумент), а именно, название новой папки, которую Вы хотите создать.

Таким же образом как регулярные глаголы, команды Unix также работают с неявными объектамм. Интерпретация зависит от контекста. Если мы скажем "ещь!" мы обычно имеем в виду, "Ещь еду, которая находится перед тобой". У команды Unix __ls__ также есть такой контекстно-зависимый, неявный объект. Команда __ls__ в самом деле скажет: "дай мне список содержания папки, где я нахожусь сейчас". 

Если Вы хотите перечислить содержание определенной папки, Вы должны написать имя папки (см. ниже). То же самое относится к команде __cal__. Печатая __cal__, Вы получаете календарь текущего месяца. Если Вы хотите знать, какой день недели началось новое тысячелетие, напишите __cal 2000__. Позже мы будем также посмотреть на команды с двумя объектами.


Команды могут также быть модифицированы. Программисты называют модификаторы команд вариантами или флагами. Различные команды принимают различные модификаторы или флаги, и значение флага варьируется от команды до команды. Флаги, как правило, состоят из одной буквы или числа, с предшествующим дефисом. Например, команда __cal__ имеет флаги __-m__ (m = Monday = понедельник) и __-3__ (или любое иное число 1..12 - это порядковый номер месяца). 
Если дать команду __cal__ без флагов, первым днем недели в календари является воскресенья, а __cal -m10__ выводит календарь октября текущего года, кроме того так, что неделя начинается с понедельника. 

Резюме:

* Синтаксис команды: ''команда'' или ''команда аргумент(ы) ''  ENTER
* Команды: __date__, __cal__, __mkdir__

Команды могут быть замечены как глаголы в императиве. Эти глаголы могут быть непереходными или переходными (имеющие ни одного, одного или более одного аргументов), и они могут быть дополнены с модификаторами (флагами).

!!Пейзаж Unix

Ваш корневой каталог расположен в другой папке. Это также содержит другие папки - корневые каталоги других пользователей. Структура системы папок можно сравнить с родословным деревом. Мать всех папок - корневой каталог системы. У корневого каталога есть свой собственный символ в Unix, а именно, __/__. 

Чтобы видеть содержание корневого каталога, Вы можете напечатать __ls /__, т.е. "перечислять содержание корневого каталога". Не забудьте нажимать ENTER. Там Вы будете видеть некоторые загадочные имена - названия различных папок и файлов.

На системах Linux папку пользователей называют __home__. Соответствующюю папку на компьютерах Mac называют __Users__. Эта папка содержит личные папки всех пользователей на системе. Если Вы работаете над личным ноутбуком, Вы, вероятно, единственный пользователь. Команда __ls /home__ или __ls /Users__ перечисляет содержание папки. Одно из имен пользователя - Ваше. 
Если Вы напишете просто __ls__, то Вы будете видеть все файлы и папки, которые Вы имеете в папке, где Вы находитесь прямо сейчас.


Резюме:

* корневой каталог (корневая папка)  __/__
* Структура каталогов: дерево. В графическом интерфейсе пользователя каталогов называют папками.
* Команда: __ls__


!!Создание папок и перемещения в системе папок

Создайте папку для этого курса, давайте назовем его __unixcourse__. Таким образом, напишите __mkdir unixcourse__. Напишите __ls__, и Вы видите, что папка была создана. Если Вы тогда печатаете __ls unixcourse__, Вы можете узнать то, что в новой папке. Да, совершенно верно, ничто.

Тогда попытайтесь двинуться в папку. Напечатайте __cd unixcourse__. Проверьте, если приглашение (текст налево от курсора) измененилось. Если Вы тогда печатаете __ls unixcourse__, Вы получаете абсолютно различный ответ, чем предыдущий раз. Почему?

Причина того, что Вы теперь получаете ответ "нет такого файла или каталога" (или нечто подобное) состоит в том, что папка __unixcourse__ не содержит папку, названную "unixcourse". Создайте теперь новую папку, например. __mkdir somename__. Вы можете тогда вернуться к своему корневому каталогу, печатая __cd ..__ (__cd__ пробел точка точка). Значение двух точек - "родительский каталог". Вы можете тогда напечатать __ls unixcourse__ и получить ответ "somename". 

Вы можете использовать символы __..__ также в других контекстах. Команда __ls ..__ означает, "перечислите содержание родительского каталога папки, где я нахожусь". Если Вы стоите в папке __unixcourse__, и Ваш корневой каталог содержит, например, папки __unixcourse__ и __Documents__, Вы можете перечислить содержание Документов, печатая __ls ../Documents__. Точки (..) означают "один уровень вверх", и косая черта (/) означает "один уровень вниз". Имя __Documents__ определяет, содержание какой папки нужно перечислить.


Одна папка более важна, чем все другие папки: Ваша корневая папка. Если Вы находитесь в папке __unixcourse__ и хотите пойти домой, Вы могли бы написать __cd ..__. Но если Вы не уверены, где Вы, или Вы хотите сразу пойти домой, Вы можете написать только __cd__. Команда перемещает Вас в Вашу корневую папку.

Если Вы хотите узнать, где Вы, напишите __pwd__ - это означает "print working directory" ("печатать рабочую папку"). В ответ Вы получите путь от корневой папки до папки, где Вы находитесь прямо сейчас.


Резюме:

Структура папок: родительская папка, рабочая папка, подпапка ...

Команды: 
* __cd__ (перемещает меня домой) 
* __cd ..__ (перемещает меня один уровень вверх в структуре папок) 
* __pwd__ (скажет, в какой папке я нахожусь)

!!Относительная и абсолютная ссылка

В Unix-е есть два способа указать на файлы и папки  - с помощью абсолютной или относительной ссылки. До сих пор мы использовали относительные ссылки. Когда мы используем относительную ссылку, ссылка зависит от того, где мы стоим. Предположим, что Вы находитесь в корневой папке, и там есть подпапка, названная __unixcourse__. Тогда возможно написать __ls unixcourse__. 
Но если Вы стоите в родственной папке Documents, это не возможно, тогда Вы должны написать __ls ../unixcourse__, чтобы видеть содержание. Относительная ссылка таким образом относительно того, где Вы в системе, когда Вы пишете команду. 

Если Вы используете абсолютную ссылку, неважно где Вы стоите, потому что абсолютная ссылка показывает Вам, где файл или папка расположен, начиная с корневой папки (__/__). Если Ваше имя пользователя __trond__, то печатая __ls /Users/trond/unixcourses/__ будет работать, независимо от того в какой папке Вы находитесь. Ссылка на папку __unixcourse__ больше не относительная, но абсолютная, это дано относительно корневой папки.



Резюме:

* Относительная ссылка зависит от того, где Вы находитесь в системе папок.
* Абсолютная ссылка - полный путь от корневой папки (через все промежуточные уровни) до папки, которую Вы хотите указать. Абсолютная ссылка __не зависит__ от того, где Вы находитесь в системе папок.


!!Просмотр содержимого файлов

Пойдите в папку __unixcourse__, которую Вы только что создали. Если Вы не знаете, где Вы, тогда Вы можете сначала написать команду __cd__, и после того __cd unixcourse__. Вы можете создать несколько файлов. Позже мы будем создать файлы с редактором текста, теперь мы сделаем их немного более удобным способом - с командой __cat__. Напишите __cat > n-list__. Ответ - не обычное приглашение, а пустая строка. Напишите одно слово, например, __Jane__, и нажмите ENTER. Напишите другое имя, например, __John__, и нажмите ENTER. 
Напишите еще немного имени, например, __Peter__, __Anne__, __Mark__, __Lena__, с ENTER после каждого имени. Наконец конец команду __Ctrl-d__ (удержите клавишу __CTRL__ и нажмите букву __d__). Теперь Вы должны видеть приглашение. Символ ">" в команде означает "послать продукцию предыдущей команды в файл, имя которого напишено после ">" символа." Эта команда таким образом создает текстовый файл "n-list".

Если Вы тогда печатаете __ls__, Вы видите, что у Вас есть файл, а именно, "n-list". Если Вы хотите знать, что находится в файле, Вы можете написать __cat n-list__. Команда __cat__ тогда напечатает целое содержимое файла на экране.

Если бы список имен в файле был очень длинным, то Вы предпочли бы просмотреть его постранично. Чтобы добывать это, напишите __less n-list__. Вы можете двигаться вперед на следующую страницу, нажимая клавишу ENTER или пробел. Когда Вы приедете до конца файла, Вы видете слово END в конце вывода. Чтобы возвратиться к командной строке (Вы не должны просмотреть целый файл!), нажмите клавишу __q__.

Резюме:

Команды: 
* __cat__, __cat > имя файла__, __less__
* Возвращаться к командной строке: __q__

!!Команды для обработки содержимого файлов

__sort__

Мы используем содержимое файла __n-list__ из предыдущей секции в качестве примера, чтобы изучить некоторые очень важные команды. Одна обыкновенная задача - сортировать строки в файле. Напишите __sort n-list__, и Вы получаете список имен, которые были в файле, в алфавитном порядке. (Более легкий способ, который дает тот же результат, состоит в том, что написать __sort n__ и затем нажать __ТАБУЛАТОР__. Если ''n-list'' является единственным файлом в папке, имя которого начинает с __n__ , то Unix заполнит имя файла для Вас.)

Команду __sort__ можно модифицировать с флагами. Флаги написаны с начальным дефисом (-) и помещены между командой и аргументом. Вместо того, чтобы писать __sort n-list__ , Вы можете написать __sort -r n-list__. Флаг __-r__ означает "reverse" ("обратный"), и файл таким образом сортирован в обратном порядке.


Резюме:

* Команда: __sort__ - алфавитная сортировка
* флаг __-r__ - сортировка в обратном порядке



__grep__

Следующая центральная команда - __grep__. Это обозначает, "get regular expression" ("достать регулярное выражение"), и отфильтрует все строки, которые имеют заданного типа. Напишите __grep J n-list__, и Вы получите в ответ __Jane__ и __John__. Напишите __grep a n-list__, и Вы получите в ответ __Jane__ и __Lena__ (но не __Anne__).
Чтобы искать более сложные выражения, используйте единственные или двойные кавычки. Команда __grep mii имя_файла__ находит из текста на северосамском языке  как ''mii'' так и ''huksemiid''. Чтобы искать ''mii'' только в начале слов, Вы можете написать __grep ' mii' имя_файла__. Чтобы только искать целое слово ''mii'', пользуйте флаг __-w__ (__grep -w mii имя_файла__).


Резюме:

* Команда: __grep__ - отфильтровать строки
* кавычки для более сложные выражения
* флаг __-w__ - искать целое слово


__rev__

Команда __rev__ полностью обратит строку. Напишите __rev n-list__ и посмотрите, что произошло.

Видели? Все имена теперь написаны обратно. Может быть, это сам по себе не очень интересно, но если мы объединяем __rev__ с другими командами, оно будет очень полезно для нас.


Резюме:
* Команда: __rev__, обратная строка ('отец' становится 'цето')

!!Объединение команд с __|__

Символ __|__ (вертикальная черта или труба или пайп) - один из главных символов в Unix. На Макинтоше труба найдена на __alt-7__, на других компьютерах, символ трубы может быть найден на клавише налево от номера 1 в левом верхнем углу или направо от LEFT SHIFT в левом нижнем углу клавиатуры. С помощью символа __|__ мы объединяем команды, или скорее: мы посылаем продукцию (вывод) из первой команды, как ввод к следующему. 

Мы теперь объединяем команды __rev__ и __sort__, и мы делаем это следующим образом: __rev n-list | sort | rev__. Что произошло? Мы обратили имена в нашем файле, обратили список, и обратили имена назад к нормальному. Результат - список имен, с которого мы начали, сортированный по последней буквой.


Резюме:
Символ труба __|__ берет продукцию от предыдущей команды и вводит к следующему.



__wc__

Давайте теперь расширим наш файл с некоторыми именами. Напишите __cat >> n-list__ и нажмите ENTER. Вы получаете пустую строку. Напишите имена __Peter__, __Ben__, __Anne__ и __Mark__, ENTER после каждого имена. Тогда нажмите __Ctrl-d__. Различие между символами > и >> - то, что в первом случае Вы создаете новый файл (или Вы переписываете старое), тогда как во втором случае, Вы добавляете новое содержимое к уже существующему файлу. 

Это - ОЧЕНЬ ВАЖНОЕ различие. Если Вы работали долгое время с файлом и написали сотни строки текста, и просто хотите добавить пару слов в конец, используйте >>. Однако, если Вы забываете и пишете > вместо этого, все те сотни строки исчезли, и все, что остается - те два слова, которые Вы хотели бы добавить. Unix не знает милосердия. Вы не вернете те сотни строки. Так, будьте осторожны!

Теперь скажем, это сделано, и у Вас есть файл, который содержит девять имен. Как узнать количество имен в файле? Ответ: команда __wc__ (количество слов). Напишите __wc n-list__, и Вы видите, сколько строк, слов и символов этот файл содержит. Если Вы только хотите видеть один из трех ответов, Вы можете сделать это с флагом __-l__ (lines = строки), __-w__ (words = слова) и __-c__ (characters = символы, т.е. буквы, остальные знаки на клавиатуре, пробелы и.т.д.), например: __wc -l__. Флаги могут также быть объединены: __wc -lw__ выводит, сколько строк и слов файл содержит.


Резюме:

* Команда: __wc__, выводит, сколько строк, слов и символов содержится в файле
Пометить: у команды __wc__ есть флаги __-l__, __-w__ и __-c__ (строки, слова и символы)
* символ __>>__: Добавляет данные, которые Вы посылаете его, в конец файла. 

__uniq__

В файле __n-list__ некоторые из строк теперь идентичны. Напишите __sort n-list__, и Вы будете видеть это. Если Вы интересуетесь только тем, сколько различных строк есть в файле, а не повторениями, Вы можете напечатать {{sort n-list | uniq}}. Если Вы хотите знать количество повторении каждого имени, Вы можете добавить флаг __-c__, который обозначает "количество", к команде __uniq__: {{sort n-list | uniq -c}}. Более продвинутая команда - следующая (вычисляет количество повторений для каждого имена и сортирует список имен по количеству повторений):

{{sort n-list | uniq -c |  sort -n}}

Команда становится еще лучше с флагом __-nr__:

{{sort n-list  | uniq -c |  sort -nr}}

С этой командой мы создали "частотный словарь". Наиболее распространенные слова в начале, и уникальные в конце. Слова с той же самой частотой сортированы в алфавитном порядке.


__tr__

Команда __tr__ заменяет одну букву (или любой символ) на другую. Эта команда отличается от других команд в том, что она не принимает имя файла в качестве аргумента. Чтобы изменить все буквы "e" на "x" в файле __n-list__, введите команду

{{cat n-list  |  tr 'e' 'x'  |  less}}

(Помните, что Вы оставляете программу __less__, нажимая __q__). Эта команда дает Вам результат на экране. Если Вы хотите сохранить результаты в файле, напишите 

{{cat n-list | tr 'e' 'x' > newfile}}


Новый файл тогда сохранен как "newfile". Обратите внимание на то, что Вы не можете использовать имя исходного файла для файла результатов.

Мы можем также использовать команду __tr__ для превращения текста в список (текстовый файл, в котором на каждой строке - одно слово). Чтобы достигнуть этого, мы заменяем все пробелы на символ новой строки, который записывается как __"\n"__. Мы также можем превращать список в текст:

{{{
cat n-list | tr "\n" " "  > n-text
}}}

