Unix для лингвистов

Введение

Некоторые команды ОС Unix являются очень полезными инструментами для лингвистов - они способны обрабатывать объёмные массивы текстов быстро и эффективно. Чтобы быть в состоянии использовать Unix, мы должны использовать интерфейс командной строки Unix. Это - краткое введение в Unix. После каждой секции маленькое резюме.

Unix найден на Linux и на Mac OS X. Применение, которое мы используем, чтобы дать команды, обычно называют Терминалом. На MS Windows нет никакого Unix. Вы можете установить виртуальную машину Linux на Вас компьютер Windows. Альтернативно, у Вас должен быть счет на другой машине Unix. Вы можете войти в этот компьютер и использовать экран и клавиатуру на Вашей машине Windows. Чтобы подписаться в Вас, может, например, использовать программу Putty.exe.

Чтобы использовать Unix на Mac, или Linux просто открывают предельную программу. На Mac это расположено в папке для программ помощи. В Linux терминал находится в папке для программирования инструментов. Мы теперь предполагаем, что у Вас есть доступ к Unix на Вашей собственной машине


Основные команды


Команды, не щелчок мыши

Unix отличается от большинства других операционных систем, в которых у него нет графического интерфейса пользователя. Вместо этого Unix имеет то, что мы называем командной строкой, т.е. курсор ждет Вас, чтобы войти в команду. Прямо после того, как Вы зарегистрировались в свой корневой каталог, Вы находитесь в своем корневом каталоге. Налево от курсора есть короткий текст, который говорит Вам, в каком папке Вы находитесь прямо сейчас. 

Вы теперь изучите много команд. Команды должны быть написаны определенным способом. У команды Unix есть две обязательных части: команда должна начаться с названия программы, и это закончено, когда Вы нажимаете клавишу ENTER. 

* Мы пробуем простую команду: 
** Напишете __date__ и нажимаетe ENTER. 
** В ответ Вы должны получить текущую дату и время. 
* Другая команда: 
** Напишите __cal__ и нажмите ENTER. 
** Ответ должен быть маленьким календарем. 

С этого времени мы предположим, что Вы всегда нажимаете ENTER после команды. Поэтому "пишете __ls__" означает "пишете __ls__, и нажмите ENTER", и так же для других команд.

Большинство команд берет один или несколько аргументов. Одна такая команда - __mkdir__, что означает, "делайте папку" или создаёте папку. Попробуйте его: Напишите __mkdir__, нажмите ENTER, и Вы получите логический ответ. Чтобы заставить папку в Unix нуждается в аргументе, имя папки. Напишите например __mkdir hogwash__. Чтобы видеть, что произошло, напишете __ls__ (перечислите содержание папки, в котором Вы находитесь прямо сейчас). Папку, которую только что сделали, можете теперь удалить, печатая __rmdir hogwash__. Попробуйте его, и затем попробуйте его снова. (Команда __rmdir__ работает только с пустыми папками.)

С лингвистической точки зрения мы можем смотреть на команды как на глаголы. Так как все команды представляют наши запросы компьютеру, мы можем рассмотреть их как глаголы в императиве. Как другие глаголы также Unix командует переходный или непереходный. Команда как __date__ может быть замечена как непереходный глагол: Вы пишете __date__, и машина говорит Вам, какой сегодня день. Команда __mkdir__, однако, является переходным глаголом, у нее должен быть объект, а именно, название новой папки, которую Вы хотите создать.

Таким же образом как регулярные глаголы, команды Unix также работают с неявным объектом. Интерпретация зависит от контекста. Если мы говорим, "ещь!" мы обычно имеем в виду, "Ещь еду, которая находится перед Вами". У команды Unix __ls__ также есть такой контекстно-зависимый, неявный объект. То, что Вы действительно говорите, является "списком содержания папки, где я нахожусь сейчас". Если Вы хотите перечислить содержание определенной папки, Вы должны написать имя папки (см. ниже). То же самое относится к команде __cal__. Печатая __cal__, Вы получаете календарь этого года. Если Вы хотите знать, какой день недели мы начали новое тысячелетие, напишете __cal 2000__. Мы будем позже смотреть на команды с двумя объектами, версией Unix двупереходных глаголов.


Команды могут также быть изменены. Мы можем назвать эти наречия модификаторов, но программатики называют их вариантами или флагами. Различные команды берут различные наречия или флаги, и значение флага варьируется от команды до команды. Флаги, как правило, состоят из одного письма или числа, и они начинают с дефиса. На некоторых системах флаги __-m__ вызывают в понедельник, чтобы быть первым днем недели вместо воскресенья), и-3 (шоу месяцем ранее и месяц после). 

Резюме:

* Синтаксис команды: название команды или аргумент названия команды ВХОДЯТ
* Команды: __date__, __cal__, __mkdir__

Команды могут быть замечены как глаголы в императиве. Эти глаголы могут быть непереходными или переходными (не имейте ни одного, одного или более аргументов), и они могут взять наречия изменения (флаг)

Пейзаж Unix

Ваш корневой каталог расположен в другой папке. Это также содержит другие папки. Но где-нибудь цепь директивной остановки. Мать всех папок - папка корня. У этого есть свой собственный символ в Unix, а именно, /. Чтобы видеть содержание Вашего собственной папки корня, Вы можете напечатать __ls /__, т.е. "перечисляют содержание папки корня". Не забудьте нажимать ENTER. Там Вы будете видеть некоторые загадочные имена, все названия различных папок.

На системах Linux папку в корне dicrectory называют __home__. Соответствующий папку на компьютерах Mac называют __Users__. Эта папка содержит всех пользователей на системе. Если Вы работаете над ноутбуком, Вы - вероятно, единственный пользователь. Команда __ls /home__ или __ls /Users__ перечисляет содержание. Одно из имен пользователя Ваше. Если Вы напишете просто __ls__, то Вы будете видеть все файлы и папки, которые Вы имеете в папке, где Вы находитесь прямо сейчас.


Резюме:

* корневая папка, папка корня (/)
* Структура каталогов: Папки друг в друге. В графическом интерфейсе пользователя их называют папками
* Команды: __ls__, ls


Создание папок и перемещения

Создайте папку для этого курса, давайте назовем его __unixcourse__. Вы таким образом пишете __mkdir unixcourse__. Напишите __ls__, и Вы видите, что папка была создана. Если Вы тогда печатаете __ls unixcourse__, Вы можете узнать то, что в новой папке. Да, совершенно верно, ничто.

Тогда попытайтесь двинуться в папку. Напечатайте __cd unixcourse__ (папка изменения "средств __cd__"). Проверьте если быстрое изменение. Если Вы тогда печатаете __ls unixcourse__, как только Вы получаете абсолютно различный ответ, чем последнее. Почему?

Причина Вы теперь получаете ответ "Никакой такой файл или папка" (или эквивалентный) состоит в том, что папка __unixcourse__ самостоятельно не содержит папку, названного "unixcourse". Создайте теперь новую папку, сочиняя, например. __mkdir somename__. Вы можете тогда вернуться к своему корневому каталогу, печатая __cd__ . (__cd__ делает интервалы между точечной точкой), Teh две точки, средние "родительский каталог к папке, я теперь помогаю". Вы можете тогда напечатать __ls unixcourse__ и получить ответ "somename"). Вы можете использовать символы.. также в других контекстах. Команда __ls__. означает, "перечисляют содержание родительского каталога к папке, я теперь помогаю". Если Вы стоите в папке __unixcourse__, и Ваш корневой каталог содержит, например, папки __unixcourse__ и Документы, Вы можете перечислить содержание Документов, печатая __ls../documents__. Точки.. означает, что "каждый выравнивает", и / означает, что каждый уравнивает. Имя Документы говорит, из какой папки система перечислит содержание.


Одна папка более важна, чем все другие папки: корневая папка. Если Вы находитесь в папке __unixcourse__ и хотите пойти домой, Вы могли бы написать __cd ..__ Но если Вы не уверены, где Вы, или Вы пойдете непосредственно домой, Вы можете написать только __cd__. Команда перемещает Вас назад в корневую папку.

Если Вы задаетесь вопросом, где Вы, Вы можете написать __pwd__, что означает "печать рабочую папку". В ответ Вы получите путь от папки корня до папки, где Вы находитесь прямо сейчас.


Резюме:

Структура папок: родительская папка, папка дочери, примечание..

Команды: 
* __cd__ (перемещает меня домой), 
* __cd ..__ (перемещает меня одну папку), 
* __имя cd__ (перемещает медиану, чтобы назвать

Относительная и абсолютная ссылка

Есть два способа относиться к файлам и папкам в Unix. Каждый абсолютный, и другой относительно. Путем мы использовали, до сих пор относительный. Когда мы используем относительную ссылку, ссылка зависит от того, где мы стоим. Предположим, что Вы находитесь в корневой папке, и Вы там папка, названная __unixcourse__. Тогда возможно написать __ls unixcourse__. Но если Вы стоите в родственной папке Documents, это не возможно, тогда Вы должны написать __ls ../unixcourse__, чтобы видеть содержание. Относительная ссылка таким образом относительно того, где в системе Вы - когда Вы пишете команду. 

Когда Вы используете абсолютную ссылку, она не играет роли, где Вы стоите, потому что абсолютная ссылка показывает Вам, где файл или папка расположен, обратившись к папке корня, который называют __/__. Если Ваше имя пользователя будет __trond__, то печатая __ls/Users/trond/unixcourses/__ будет работать, независимо от того в какой папке Вы находитесь. Ссылка на папку __unixcourse__ больше не относительная, но абсолютная, это дано относительно папки корня.



Резюме:

* Относительная ссылка, в зависимости от того, как Вы находитесь в системе
* Абсолютная ссылка относится через папку корня


Рассмотрите содержание файлов

Пойдите в папку __unixcourse__, которую Вы только что создали. Если Вы не знаете, где Вы, Вы можете сначала написать команду __cd__, и после того __cd unixcourse__. Вы можете создать несколько файлов. Позже мы создадим файлы с редактором текста, теперь мы делаем их немного более удобным способом с командой __cat__. Напишите __cat > n-list__. Ответ не обычное быстрое, но пустая строка. Напишите слово, например, __Jane__, нажмите ENTER. Напишите другое имя, например, __John__, и нажмите ENTER. Напишите еще немного имени, например, __Peter__, __Anne__, __Mark__, __Lena__, с ENTER после каждого имени. Наконец конец команду __Ctrl-d__ (удерживают клавишу __CTRL__ и нажимают ключ __d__). Теперь Вы должны возвратить быстрое. Символ ">" означает, "посылают продукцию предыдущей команды к файлу после ">" символ. Эта команда таким образом создает файл "n-list".

Если Вы тогда печатаете __ls__, Вы видите, что у Вас есть файл, а именно, "n-list". Если Вы задаетесь вопросом, что находится в файле, Вы можете написать __cat n-list__. Команда __cat__ тогда представит целое содержание файла и напечатает его на экране.

Если бы файл был очень длинен, то Вы предпочли бы иметь его один screenful за один раз. Чтобы получить это, Вы можете написать __less n-list__. Для файла, простирающегося по нескольким screenlengths, Вы можете читать вперед, нажимая клавишу ENTER. Когда Вы приедете до конца файла, он скажет END в обратном видео. Чтобы оставить меньше команды и возвратиться к командной строке, нажмите ключ __q__.

Резюме:

Команды: 
* __cat__, __cat > имя файла__, __less__
* Выходят из меньшего-количества-функции и возвращаются к командной строке: __sort__ __q__
* Команды, чтобы управлять содержанием файлов


__sort__

Содержание __n-list__ файла в предыдущей секции может использоваться в качестве примера, чтобы изучить некоторые очень важные команды. Мы хотели бы сортировать линии файла. Напишите __sort n-list__, и Вы расположили в алфавитном порядке файл, каждая линия в алфавитном порядке. (Более легкий путь состоял бы в том, чтобы написать __sort n__ и затем нажать __ТАБУЛАТОР__. Если n-list будет единственным файлом в папке, у которой есть __n__ как его первое письмо, то Unix заполнит остальных для Вас).

Эта команда мы можем тогда изменить с флагами (наши "наречия"). Флаги написаны с начальным дефисом (-) сначала и помещены между командой и аргументом. Вместо того, чтобы писать __sort n-list__ Вы можете написать __sort -r n-list__. Флаг __-r__ означает "полностью измененный", и файл таким образом сортирован в обратном порядке.


Резюме:
* Флаги, флаг __-r__
* Команда: __sort__

__grep__

Другая центральная команда - __grep__. Это обозначает, "получают регулярное выражение", и вытаскивает все линии, которые имеют тип, который Вы определили. Напишите __grep J n-list__, и Вы получаете __Jane__ и __John__ как ответ. Напишите __grep a n-list__, и Вы получаете __Jane__ и __Lena__ (но не __Anne__!) как ответ.

Чтобы искать более продвинутые выражения, Вы используете единственные или двойные кавычки. Команда __grep mii имя_файла__ в тексте Сами находит и 'mii' и 'huksemiid'. Чтобы искать только __mii__ в начале слов, Вы можете написать __grep 'mii' имя_файла__. Чтобы искать слово 'mii', Вы можете написать флаг __-w__ mii имя_файла

__rev__

Команда __rev__ полностью изменяет линии. Напишите __rev n-list__ и посмотрите то, что произошло.

Вы видели это? Все имена теперь написаны назад. Это сам по себе не настолько захватывающе, возможно, но, когда объединено с другими командами это будет очень полезно для нас.



Резюме:
* Команда: __rev__, обратная линия ('отец' становится 'цето'),

Объединение команд с __|__

Характер __|__ или труба, один из главных символов в Unix. На Макинтоше труба найдена на __alt-7__ на других компьютерах, символ трубы может быть найден на ключе налево от номера 1 в левом верхнем углу клавиатуры. С | мы объединяем многократные команды, или скорее: мы посылаем продукцию из первой команды, как введено к следующему. Мы теперь объединим оборот команд и вид, и мы делаем это следующим образом: __rev n-list | sort | rev__. Что произошло? Мы полностью изменили имена в нашем файле, обратным списком, и повернулись назад к нормальному, оставленному более высокому тексту. Результат - сортированный список перемены имен, с которыми мы начали.



Резюме:
Символ трубы __|__ берет продукцию от предыдущей команды, как введено к следующему.

__wc__

Давайте теперь расширим наш файл с некоторыми другими именами. Напишите __cat >> n-list__ и нажмите ENTER. Вы получаете пустую строку. Напишите имена __Peter__, __Ben__, __Anne__ и __Mark__, все с ENTER между ними. Тогда нажмите __Ctrl-d__. Различие между символами > и >> - то, что в первом случае Вы создаете новый файл (или Вы переписываете старое), тогда как во втором случае, Вы добавляете новое содержание к уже существующему файлу. Это - очень важное различие. Если Вы работали долгое время с файлом и написали сотни линий текста, и просто хотите добавить слово или два в конце, используйте >>. Однако, если Вы забываете и пишете > вместо этого, все те сотни линий исчезли, и все, что возвращено, два плохих слова, которые Вы хотели бы добавить. Unix не знает милосердия. Вы не вернете те сотни линий. Так будьте осторожны.

Теперь скажем, это все подходит, и у Вас есть файл, который содержит в общей сложности девять имен. Как Вы знаете, что есть 9? Команда __wc__ (количество слов). Напишите __wc n-list__, и Вы видите, сколько линий, слов и изображает файл, содержит. Если Вы только хотите видеть один из трех ответов, Вы можете сделать это с флагом __-l__, __-w__ и __-c__, следующим образом: __wc -l__. Флаги могут также быть объединены: __wc -lw__ говорит, сколько линий и слов файл содержит.



Резюме:


Резюме:

* Команда: __wc__, говорит, сколько линий, слов и знаков там находится в файле
Пометить: у команды __wc__ есть флаги __-l__, __-w__ и __-c__ (линии, слова и знаки)
* символ __>>__: Добавляет содержание до конца файла, в который Вы посылаете его

__uniq__

В файле __n-list__ несколько из линий теперь идентичны. Напишите __sort n-list__, и Вы будете видеть его. Если Вы интересуетесь только тем, сколько различных линий Вы имеете, а не повторениями, Вы можете напечатать __sort n-list | uniq__. Если Вам интересно, в том, сколько есть каждого имени, Вы можете добавить флаг __-c__, который обозначает "количество" к команде __uniq: sort n-list | uniq -c__. Более продвинутая команда - следующий, который виды согласно числу пунктов:

__sort n-list | uniq -c | sort -n__

Команда становится еще лучше с выбором __-nr__:

__sort n-list | uniq -c | sort -nr__

С этой командой мы сортировали список частотой. Наиболее распространенные слова на первом месте, и уникальные в конце. Слова с той же самой частотой сортированы в алфавитном порядке.


__tr__

Команда __tr__ изменяет характер на другого. Эта команда отличается от других команд, не беря имена файла в качестве аргумента. Чтобы изменить все письма "e" на "x" в файле __n-list__, войдите в команду

__cat n-list | tr 'e' 'x' | less__

(Помните, что Вы оставляете программу меньше, нажимая __q__). Эта команда дает Вам результат на экране. Если Вы хотите спасти результаты к новому типу файла вместо этого, Вы можете напечатать 

__cat n-list | tr 'e' 'x' > newfile__

Новый файл тогда сохранен как "newfile". Обратите внимание на то, что Вы не можете использовать то же самое имя на файле назначения и исходном файле.



Очень полезная команда __tr__ - та, которая превращает текст в список с одним словом за линию. Чтобы достигнуть этого, мы заменим все места newline характером. newline характер мы пишем как '\n'. Начиная с какого мы имеем, список, мы начинаем, превращая его в текст:

__cat n-list | tr '\n' ' ' > n-text__

Если Вы тогда печатаете __cat n-text__, Вы, wil видят, что имена перечисляют, находятся теперь на той же самой линии. Вы можете возвратиться к формату списка, повернув команду и написать:

__cat n-текст | tr ' ' '\n'__



Творческая лень: многократное использование той же самой команды

Очень скоро команды становятся длинными. Вместо того, чтобы печатать ту же самую команду снова и снова, Вы можете использовать клавиши курсора. Ключ Стрела дает Вам предыдущую команду. Чтобы выполнить его, Вы должны, очевидно, нажать клавишу ENTER). Стрела еще раз дает Вам команду перед предыдущей.

Если Вы тогда пишете историю, Вы получаете список всех команд, которые Вы сделали. У каждой команды есть число. Если Вы хотите сделать, например, команду номер 55 снова, напишите! 55, и та же самая команда выполнен снова.

Длинные команды могут также быть, редактируют. Давайте скажем, что Вы написали команду

__grep e n-list | rev | sort | rev __


Результатом был сортированный список перемены всех имен, который содержит __e__. Вы можете теперь нажать Стрела, получить команду снова и нажать клавишу "влево", пока Вы не достигаете __e__. Вы тогда удаляете его и пишете __a__ вместо этого, и после того Вы нажимаете ENTER. Результат - сортированный глоссарий перемены всех имен, содержащих гласный __a__.

Если команда длинна, она может занять время, чтобы добраться до начала. Более быстрый способ добраться там нажимает __ctrl-a__. Чтобы возвратить до конца Вас нажимают __ctrl-e__.


Резюме:

история показывает предыдущие команды
__ctrl-a__, __ctrl-e__
Восклицательный знак плюс число правила дает ту же самую команду снова.



Копия, переместите и переименуйте файлы

Файлы скопированы с командой __cp__ (для "скопируй"). Скопировать файл __n-list__ к новому файлу, который Вы можете назвать __n-list2__, напишете __cp n-list n-list2__. Команда - таким образом "cp от к". Чтобы дать файлу новое имя, используйте команду __mv__ (движение). Синтаксис - то же самое: старое название __mv новое_имя__. Имя __mv__ действительно означает движение. Попытка, сначала делающая новую папку: 

__mkdir oldfiles__

Тогда команда:

__mv n-list2 oldfiles__

не превратит __n-list2__ в файл, названный __oldfiles__. Вместо этого это переместит файл __n-list2__ в папку __oldfiles__.

ПРЕДУПРЕЖДЕНИЕ: Если Вы переименуете файл к имени файла уже в использовании, то старый файл будет удален. У Unix нет кнопки сожаления, таким образом, содержание старого файла будет потеряно.


Регулярные выражения



Мы используем регулярные выражения, чтобы искать классы знаков. Как испытательный документ Вы можете взять файл ''eng_vaalit2012.txt'' в каталоге [https://victorio.uit.no/langtech/trunk/courses/unix_korpus/]. Загрузите файл. Если Вы используете Mac, и настроил папку как выше, и Вы стоите в папке __unixcourse__, Вы можете скопировать файл к папке __unixcourse__ с командой

__cp ../Downloads/eng_vaalit2012.txt .__

В команде, заключительных точечных средствах: "Скопируйте файл туда, где я теперь". Отметьте пространство между именем файла и точкой.

К глухому 'реле' последовательности в тексте, названном списком, мы написали список реле власти. Как пример мы берем эти два предложения (если Вы практикуете, Вы можете скопировать их к отдельному документу, который Вы можете назвать списком __td__).:


{{{
cat eng_vaalit2012.txt | tr ' ' '\n' | grep '^d'
cat eng_vaalit2012.txt | tr ' ' '\n' | grep 'd$'
cat eng_vaalit2012.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head
}}}

Здесь мы также ввели новую команду, __head__. Команда __head__ печатает первые 10 линий продукции.

Посредством регулярных выражений мы можем получить различные наборы слов из текста. Три после команд сдаются, все окончание слов - поело, закончив в последовательности {{любой характер __e__}}, в последовательности {{любое число знаков __e__}}. Заключительная команда дает все слова, заканчивающиеся в __d__, которому предшествует характер кроме __e__.

{{{
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'ate$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.*e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '[^e]d$'
}}}



Также возможно искать классы звуков. Таким образом [aeiouy] - класс всех гласных на английском языке. Этот поиск возвращает все слова, содержащие согласный __c__ плюс гласный:

__grep 'c [aeiouy]' eng_vaalit2012.txt__


Могут быть объединены все регулярные выражения. Как делают мы представляем все случаи __o__ плюс любой характер плюс гласный:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'o.*[aeiouy]'__

Скобки могут также использоваться, чтобы искать и заглавные и строчные буквы:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^in'__
__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^[Ii]n'__


Если мы хотим искать несколько последовательностей, нам нужна расширенная команда __grep__, __egrep__.
Здесь прибывает все слова, заканчивающиеся в __-ing__ или __-ed__.

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|egrep' (ing|ed)$'__



Больше информации о регулярных выражениях найдено на Википедию:
* [http://en .wikipedia.org/wiki/Regular_expression]
* [http://ru .wikipedia.org/wiki/Регулярные_выражения]


Встроенная система справочной информации Unix: __man__, __apropos__ и __info__

У Unix есть очень хорошая встроенная система справочной информации. Если Вы знаете название команды и хотите больше информации, Вы можете написать __man__ и названию команды (например, __man grep__). 

Есть две проблемы с этой информацией: Вы должны знать название команды, прежде чем Вы сможете спросить, и текст часто немного загадочный. Страницы __man__ больше всего подходят узнавать, какие флаги использовать с командой, и как они работают.

Чтобы получить более образовательный текст, Вы можете написать __info__ вместо __man__. Если также, который является слишком загадочным, Вы можете искать в сети. Чтобы получить объяснение на команду __cat__, Вы можете искать: Как использовать команду __cat__.

Если Вы не уверены в команде, Вы ищете, Вы можете написать __apropos__ название команды (для названия команды, Вы думаете возможно, что Вы ищете). Тогда __apropos__ даст Вам список названий команды, которые могли бы иметь некоторое отношение к нему (и возможно нет!). Обычно 'apropos' команда не настолько полезна.





Список команд Unix:

* [http://en .wikipedia.org/wiki/List_of_Unix_utilities]
* [http://ru .wikipedia.org/wiki/Программы_UNIX-подобных_операционных_систем]
