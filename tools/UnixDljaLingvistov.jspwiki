!!!Unix для лингвистов

!!Введение

Некоторые команды ОС Unix являются очень полезными инструментами для лингвистов - они способны обрабатывать объёмные массивы текстов быстро и эффективно. Чтобы быть в состоянии использовать эти команды, мы должны использовать интерфейс командной строки Unix. Это - краткое введение в Unix. После каждой секции маленькое резюме.

Команды Unix также найдены на Linux и на Mac OS X. Программа, которую мы используем, чтобы дать команды, обычно называют Терминалом ({{{terminal}}} или {{{xterm}}}). На MS Windows нет никакого Unix. Вы можете установить виртуальную машину Linux на Ваш Windows-компьютер. Альтернативно, Вы должны иметь пользовательский аккаунт (учетная запись) на другом компьютере с системой Unix. Вы можете войти в этот компьютер и использовать экран и клавиатуру на Вашей Windows-машине. Чтобы войти в другой компьютер, Вы можете, например, использовать программу putty.exe.

Чтобы использовать Unix на Mac или Linux нужно просто запустить приложение  {{{Terminal}}} (Терминал). На Mac это расположено в папке программ, в подпапке {{{Utilities}}} (Утилиты). В Linux терминал-программа обычно находится в папке помощных программ. Мы теперь предполагаем, что у Вас есть доступ к Unix на Вашей собственной машине.


!!Основные команды

!!Команды, не щелчок мыши

Unix отличается от большинства других операционных систем в том, что у него нет графического интерфейса пользователя. Вместо того Unix имеет то, что мы называем командной строкой, т.е. курсор стоит и ждет, чтобы Вы вводили команду. Прямо после того, как Вы открыли окно терминал-программы (и вошли в свою учетную запись, если надо), Вы находитесь в своем корневом каталоге. Налево от курсора есть короткий текст (приглашение), который говорит Вам, в каком папке Вы находитесь. 

Вы теперь изучите много команд. Команды должны быть написаны определенным способом. У команды Unix есть две обязательных части: команда должна начаться с названия программы, и команда закончена, когда Вы нажимаете клавишу ENTER. 

* Мы пробуем простую команду: 
** Напишите __date__ и нажмитe ENTER. 
** В ответ Вы должны получить текущий день недели, дату и время. 
* Другая команда: 
** Напишите __cal__ и нажмите ENTER. 
** Ответ - маленький календарь. 

С этого момента мы предположим, что Вы всегда нажимаете ENTER после команды. Поэтому "пишите __ls__" означает "пишите __ls__, и нажмите ENTER", и так же для других команд.

Большинство команд берет один или несколько аргументов. Одна такая команда - __mkdir__, что означает, "делайте папку" или создаёте папку. Попробуйте его: Напишите __mkdir__, нажмите ENTER, и Вы получите логический ответ. Чтобы заставить папку нуждается по крайней мере один аргумент - имя папки. Напишите например __mkdir hogwash__. Чтобы видеть, что произошло, напишите __ls__ (перечислите содержание папки, в которой Вы находитесь). Папку, которую Вы только что сделали, можете теперь удалить с помощью команд __rmdir hogwash__. Попробуйте команду __rmdir__, и затем попробуйте ей снова. (Команда __rmdir__ работает только с пустыми папками.)

С лингвистической точки зрения мы можем смотреть на команды как на глаголы. Так как все команды представляют наши запросы компьютеру, мы можем рассмотреть их как глаголы в императиве. Как другие глаголы так и Unix команды могуть быть переходными или непереходными. Например команда __date__ - как непереходный глагол: Вы пишете __date__, и машина говорит Вам, какое сегодня число и день недели. Команда __mkdir__, однако, является переходным глаголом, у нее должен быть объект (компьютерный термин для объекта: аргумент), а именно, название новой папки, которую Вы хотите создать.

Таким же образом как регулярные глаголы, команды Unix также работают с неявными объектамм. Интерпретация зависит от контекста. Если мы скажем "ещь!" мы обычно имеем в виду, "Ещь еду, которая находится перед тобой". У команды Unix __ls__ также есть такой контекстно-зависимый, неявный объект. Команда __ls__ в самом деле скажет: "дай мне список содержания папки, где я нахожусь сейчас". Если Вы хотите перечислить содержание определенной папки, Вы должны написать имя папки (см. ниже). То же самое относится к команде __cal__. Печатая __cal__, Вы получаете календарь текущего месяца. Если Вы хотите знать, какой день недели началось новое тысячелетие, напишите __cal 2000__. Позже мы будем также посмотреть на команды с двумя объектами.


Команды могут также быть модифицированы. Программисты называют модификаторы команд вариантами или флагами. Различные команды берут различные модификаторы или флаги, и значение флага варьируется от команды до команды. Флаги, как правило, состоят из одной буквы или числа, с предшествующим дефисом. Например, команда __cal__ имеет флаги __-m__ (m = Monday = понедельник) и __-3__ (или любое иное число 1..12 - это порядковый номер месяца). Если дать команду __cal__ без флагов, первым днем недели в календари является воскресенья, а __cal -m10__ выводит календарь октября текущего года и так, что неделя начинается с понедельника. 

Резюме:

* Синтаксис команды: ''команда'' или ''команда аргумент(ы)'' ENTER
* Команды: __date__, __cal__, __mkdir__

Команды могут быть замечены как глаголы в императиве. Эти глаголы могут быть непереходными или переходными (имеющие ни одного, одного или более одного аргументов), и они могут быть дополнены с модификаторами (флагами).

!!Пейзаж Unix

Ваш корневой каталог расположен в другой папке. Это также содержит другие папки - корневые каталоги других пользователей. Структура системы папок можно сравнить с родословным деревом. Мать всех папок - корневой каталог системы. У корневого каталога есть свой собственный символ в Unix, а именно, __/__. Чтобы видеть содержание корневого каталога, Вы можете напечатать __ls /__, т.е. "перечислять содержание корневого каталога". Не забудьте нажимать ENTER. Там Вы будете видеть некоторые загадочные имена - названия различных папок и файлов.

На системах Linux папку пользователей называют __home__. Соответствующюю папку на компьютерах Mac называют __Users__. Эта папка содержит личные папки всех пользователей на системе. Если Вы работаете над личным ноутбуком, Вы - вероятно, единственный пользователь. Команда __ls /home__ или __ls /Users__ перечисляет содержание папки. Одно из имен пользователя - Ваше. Если Вы напишете просто __ls__, то Вы будете видеть все файлы и папки, которые Вы имеете в папке, где Вы находитесь прямо сейчас.


Резюме:

* корневой каталог (корневая папка)  (/)
* Структура каталогов: дерево. В графическом интерфейсе пользователя каталогов называют папкамию
* Команды: __ls__, ls


!!Создание папок и перемещения в системе папок

Создайте папку для этого курса, давайте назовем его __unixcourse__. Таким образом, напишите __mkdir unixcourse__. Напишите __ls__, и Вы видите, что папка была создана. Если Вы тогда печатаете __ls unixcourse__, Вы можете узнать то, что в новой папке. Да, совершенно верно, ничто.

Тогда попытайтесь двинуться в папку. Напечатайте __cd unixcourse__ (папка изменения "средств __cd__"). Проверьте если приглашение (текст налево от курсора) измененилось. Если Вы тогда печатаете __ls unixcourse__, Вы получаете абсолютно различный ответ, чем предыдущий раз. Почему?

Причина того, что Вы теперь получаете ответ "нет такого файла или каталога" (или нечто подобное) состоит в том, что папка __unixcourse__ не содержит папку, названного "unixcourse". Создайте теперь новую папку, например. __mkdir somename__. Вы можете тогда вернуться к своему корневому каталогу, печатая __cd ..__ (__cd__ пробел точка точка). Значение двух точек - "родительский каталог". Вы можете тогда напечатать __ls unixcourse__ и получить ответ "somename"). Вы можете использовать символы __..__ также в других контекстах. Команда __ls ..__ означает, "перечислите содержание родительского каталога папки, где я нахожусь". Если Вы стоите в папке __unixcourse__, и Ваш корневой каталог содержит, например, папки __unixcourse__ и __documents__, Вы можете перечислить содержание Документов, печатая __ls ../documents__. Точки (..) означают "один уровень вверх", и косая черта (/) означает "один уровень вниз". Имя __documents__ определяет, содержание какой папки нужно перечислить.


Одна папка более важна, чем все другие папки: Ваша корневая папка. Если Вы находитесь в папке __unixcourse__ и хотите пойти домой, Вы могли бы написать __cd ..__ Но если Вы не уверены, где Вы, или Вы хотите сразу пойти домой, Вы можете написать только __cd__. Команда перемещает Вас в корневую папку.

Если Вы хотите узнать где Вы, напишите __pwd__ - это означает "печатать рабочую папку". В ответ Вы получите путь от корневой папки до папки, где Вы находитесь прямо сейчас.


Резюме:

Структура папок: родительская папка, рабочая папка, подпапка ...

Команды: 
* __cd__ (перемещает меня домой), 
* __cd ..__ (перемещает меня один уровень вверх в структуре папок), 
* __pwd__ (скажет в какой папке я нахожусь)

!!Относительная и абсолютная ссылка

В Unix-е есть два способа указать на файлы и папки  - с помощью абсолютной или относительной ссылки. До сих пор мы использовали относительные ссылки. Когда мы используем относительную ссылку, ссылка зависит от того, где мы стоим. Предположим, что Вы находитесь в корневой папке, и там есть подпапка, названная __unixcourse__. Тогда возможно написать __ls unixcourse__. Но если Вы стоите в родственной папке Documents, это не возможно, тогда Вы должны написать __ls ../unixcourse__, чтобы видеть содержание. Относительная ссылка таким образом относительно того, где Вы в системе, когда Вы пишете команду. 

Если Вы используете абсолютную ссылку, неважно где Вы стоите, потому что абсолютная ссылка показывает Вам, где файл или папка расположен, начиная с корневой папки (__/__). Если Ваше имя пользователя __trond__, то печатая __ls /Users/trond/unixcourses/__ будет работать, независимо от того в какой папке Вы находитесь. Ссылка на папку __unixcourse__ больше не относительная, но абсолютная, это дано относительно корневой папки.



Резюме:

* Относительная ссылка зависит от того, где Вы находитесь в системе папок.
* Абсолютная ссылка - полный путь от корневой папки (через все промежуточные уровни) до папки, которую Вы хотите указать. Абсолютная ссылка __не зависит__ от того, где Вы находитесь в системе папок.


!!Просмотр содержимого файлов

Пойдите в папку __unixcourse__, которую Вы только что создали. Если Вы не знаете, где Вы, тогда Вы можете сначала написать команду __cd__, и после того __cd unixcourse__. Вы можете создать несколько файлов. Позже мы будем создать файлы с редактором текста, теперь мы сделаем их немного более удобным способом - с командой __cat__. Напишите __cat > n-list__. Ответ - не обычное приглашение, а пустая строка. Напишите одно слово, например, __Jane__, и нажмите ENTER. Напишите другое имя, например, __John__, и нажмите ENTER. Напишите еще немного имени, например, __Peter__, __Anne__, __Mark__, __Lena__, с ENTER после каждого имени. Наконец конец команду __Ctrl-d__ (удержите клавишу __CTRL__ и нажмите букву __d__). Теперь Вы должны видеть приглашение. Символ ">" в команде означает "послать продукцию предыдущей команды в файл, имя которого напишено после ">" символа. Эта команда таким образом создает текстовый файл "n-list".

Если Вы тогда печатаете __ls__, Вы видите, что у Вас есть файл, а именно, "n-list". Если Вы хотите знать, что находится в файле, Вы можете написать __cat n-list__. Команда __cat__ тогда напечатает целое содержимое файла на экране.

Если бы список имен в файле был очень длинным, то Вы предпочли бы просмотреть его постранично. Чтобы добывать это, напишите __less n-list__. Вы можете двигаться вперед на следующую страницу, нажимая клавишу ENTER или пробел. Когда Вы приедете до конца файла, Вы видете слово END в конце вывода. Чтобы возвратиться к командной строке (Вы не должны просмотреть целый файл!), нажмите клавишу __q__.

Резюме:

Команды: 
* __cat__, __cat > имя файла__, __less__
* Возвращаться к командной строке: __q__

!!Команды для обработки содержимого файлов

__sort__

Мы используем содержимое файла __n-list__ из предыдущей секции в качестве примера, чтобы изучить некоторые очень важные команды. Одна обыкновенная задача - сортировать строки в файле. Напишите __sort n-list__, и Вы получаете список имен, которые были в файле, в алфавитном порядке. (Более легкий способ, который дает тот же результат, состоит в том, что написать __sort n__ и затем нажать __ТАБУЛАТОР__. Если ''n-list'' является единственным файлом в папке, имя которого начинает с __n__ , то Unix заполнит имя файла для Вас.)

Команду __sort__ можно модифицировать с флагами. Флаги написаны с начальным дефисом (-) и помещены между командой и аргументом. Вместо того, чтобы писать __sort n-list__ , Вы можете написать __sort -r n-list__. Флаг __-r__ означает "reverse" ("обратный"), и файл таким образом сортирован в обратном порядке.


Резюме:

* Команда: __sort__ - алфавитная сортировка
* флаг __-r__ - сортировка в обратном порядке

__grep__

Следующая центральная команда - __grep__. Это обозначает, "get regular expression" ("достать регулярное выражение"), и отфильтрует все строки, которые имеют заданного типа. Напишите __grep J n-list__, и Вы получите в ответ __Jane__ и __John__. Напишите __grep a n-list__, и Вы получите в ответ __Jane__ и __Lena__ (но не __Anne__!).

Чтобы искать более сложные выражения, используйте единственные или двойные кавычки. Команда __grep mii имя_файла__ находит из текста на северосамском языке  как 'mii' так и 'huksemiid'. Чтобы искать __mii__ только в начале слов, Вы можете написать __grep ' mii' имя_файла__. Чтобы только искать целое слово 'mii', пользуйте флаг __-w__ (__grep -w mii имя_файла__).

Резюме:

* Команда: __grep__ - отфильтровать строки
* кавычки '' или "" для более сложные выражения
* флаг __-w__ - искать целое слово

__rev__

Команда __rev__ полностью обратит строку. Напишите __rev n-list__ и посмотрите, что произошло.

Видели? Все имена теперь написаны обратно. Может быть, это сам по себе не очень интересно, но если мы объединяем __rev__ с другими командами, оно будет очень полезно для нас.


Резюме:
* Команда: __rev__, обратная строка ('отец' становится 'цето')

Объединение команд с __|__

Символ __|__ (вертикальная черта или труба или пайп) - один из главных символов в Unix. На Макинтоше труба найдена на __alt-7__, на других компьютерах, символ трубы может быть найден на клавише налево от номера 1 в левом верхнем углу или направо от LEFT SHIFT в левом нижнем углу клавиатуры. С | мы объединяем команды, или скорее: мы посылаем продукцию (вывод) из первой команды, как ввод к следующему. Мы теперь объединяем команды __rev__ и __sort__, и мы делаем это следующим образом: __rev n-list | sort | rev__. Что произошло? Мы обратили имена в нашем файле, обратили список, и обратили имена назад к нормальному. Результат - список имен, с которого мы начали, сортированный по последней буквой.


Резюме:
Символ труба __|__ берет продукцию от предыдущей команды и вводит к следующему.

__wc__

Давайте теперь расширим наш файл с некоторыми именами. Напишите __cat >> n-list__ и нажмите ENTER. Вы получаете пустую строку. Напишите имена __Peter__, __Ben__, __Anne__ и __Mark__, ENTER после каждого имена. Тогда нажмите __Ctrl-d__. Различие между символами > и >> - то, что в первом случае Вы создаете новый файл (или Вы переписываете старое), тогда как во втором случае, Вы добавляете новое содержимое к уже существующему файлу. Это - ОЧЕНЬ ВАЖНОЕ различие. Если Вы работали долгое время с файлом и написали сотни строки текста, и просто хотите добавить пару слов в конец, используйте >>. Однако, если Вы забываете и пишете > вместо этого, все те сотни строки исчезли, и все, что остается - те два слова, которые Вы хотели бы добавить. Unix не знает милосердия. Вы не вернете те сотни строки. Так, будьте осторожны!

Теперь скажем, это сделано, и у Вас есть файл, который содержит девять имен. Как узнать количество имен в файле? Ответ: команда __wc__ (количество слов). Напишите __wc n-list__, и Вы видите, сколько строк, слов и символов этот файл содержит. Если Вы только хотите видеть один из трех ответов, Вы можете сделать это с флагом __-l__ (lines = строки), __-w__ (words = слова) и __-c__ (characters = символы, т.е. буквы, остальные знаки на клавиатуре, пробелы и.т.д.), например: __wc -l__. Флаги могут также быть объединены: __wc -lw__ выводит, сколько строк и слов файл содержит.


Резюме:

* Команда: __wc__, выводит, сколько строк, слов и символов содержится в файле
Пометить: у команды __wc__ есть флаги __-l__, __-w__ и __-c__ (строки, слова и символы)
* символ __>>__: Добавляет данные, которые Вы посылаете его, в конец файла. 

__uniq__

В файле __n-list__ некоторые из строк теперь идентичны. Напишите __sort n-list__, и Вы будете видеть это. Если Вы интересуетесь только тем, сколько различных строк есть в файле, а не повторениями, Вы можете напечатать __sort n-list | uniq__. Если Вы хотите знать количество повторении каждого имени, Вы можете добавить флаг __-c__, который обозначает "количество", к команде __uniq: sort n-list | uniq -c__. Более продвинутая команда - следующая (вычисляет количество повторений для каждого имена и сортирует список имен по количеству повторений):

__sort n-list | uniq -c | sort -n__

Команда становится еще лучше с флагом __-nr__:

__sort n-list | uniq -c | sort -nr__

С этой командой мы создали "частотный словарь". Наиболее распространенные слова в начале, и уникальные в конце. Слова с той же самой частотой сортированы в алфавитном порядке.


__tr__

Команда __tr__ заменяет одну букву (или любой символ) на другую. Эта команда отличается от других команд втом, что она не принимает имя файла в качестве аргумента. Чтобы изменить все буквы "e" на "x" в файле __n-list__, введите команду

__cat n-list | tr 'e' 'x' | less__

(Помните, что Вы оставляете программу __less__, нажимая __q__). Эта команда дает Вам результат на экране. Если Вы хотите сохранить результаты в файле, напишите 

__cat n-list | tr 'e' 'x' > newfile__

Новый файл тогда сохранен как "newfile". Обратите внимание на то, что Вы не можете использовать имя исходного файла для файла результатов.



Мы можем также использовать команду __tr__ для превращения текста в список (текстовый файл, в котором на каждой строке - одно слово). Чтобы достигнуть этого, мы заменяем все пробелы на символ новой строки, который записывается как '\n'. Мы также можем превращать список в текст:

__cat n-list | tr '\n' ' ' > n-text__

Если Вы тогда печатаете __cat n-text__, Вы видите, что имена теперь стоят в ряд на той же самой строке. Вы можете возвратиться к формату списка, повернув символы новой строки и пробела в команде и написать:

__cat n-text | tr ' ' '\n'__



Творческая лень: многократное использование той же самой команды

Очень скоро команды становятся длинными. Вместо того, чтобы печатать ту же самую команду снова и снова, Вы можете использовать клавиши-стрелки. Клавиша "стрелка вверх" дает Вам предыдущую команду. Чтобы выполнить его, Вы должны, очевидно, нажать клавишу ENTER. Нажатие на "стрелка вверх" еще раз дает Вам команду перед предыдущей.

Если Вы пишете __history__, Вы получаете список всех выполненных команд, которые Вы дали. Перед каждой команды есть число. Если Вы хотите, например, дать команду номер 55 снова, напишите !55, и та же самая команда будет выполнена снова.

Вы можете тоже редактировать команды (это особенно удобнее чем написать команду снова, если команда длинная). Давайте скажем, что Вы написали команду

__grep e n-list | rev | sort | rev __


Результатом был сортированный список перемены всех имен, который содержит __e__. Вы можете теперь нажать "стрелка вверх", получить предыдущую команду снова и нажать клавишу "стрелка влево", пока Вы не достигаете __e__. Вы тогда удаляете его и пишете __a__ вместо этого, и после того Вы нажимаете ENTER. Результат - алфавитный словарь имен, содержащих гласную __a__.

Если команда длинная, то движение до начала с помощью стрелки занимает слишком много времени. Более быстрый способ добраться до начала - нажимать на __ctrl-a__. Чтобы возвратить до конца - нажимать __ctrl-e__.


Резюме:

* Клавиша "стрелка вверх" показывает Вашу предыдущую команду.
* С клавишами "стрелка влево" и "стрелка вправо" можно передвигаться в команде.
* __ctrl-a__ перемещает курсор в начало команды. 
* __ctrl-e__ перемещает курсор в конец команды. 
* __history__ показывает список всех выполненных команды.
* __!123__, где 123 - число порядки команды в списке выполненных команд, дает ту же самую команду снова.




Как копировать, переместить и переименовать файлы

Файлы можно копировать с командой __cp__ (copy). Давайте скопируем файл __n-list__ в новый файл, который Вы можете назвать __n-list2__. Для этого напишите __cp n-list n-list2__. Результат - два файла с тем же содержанием. 

Чтобы дать файлу новое имя, используйте команду __mv__ (move). Синтаксис - то же самое: __mv старое_имя новое_имя__. Имя __mv__ действительно означает движение, если мы вместо нового имя напишем имя некоторой папки. 

Маленькая попытка: 
Сначала создаем новую папку: 

__mkdir oldfiles__

Тогда команда

__mv n-list2 oldfiles__

не превратит __n-list2__ в файл, названный __oldfiles__. Вместо того команда переместит файл __n-list2__ в папку __oldfiles__.

__ОСТОРОЖНО! Если Вы переименуете файл в имя, которое уже существует, то старый файл будет удален. У Unix нет кнопки отмены, таким образом, содержание старого файла будет потеряно.__


Регулярные выражения


Мы используем регулярные выражения, чтобы искать классы символов. Как испытательный документ Вы можете взять файл ''eng_vaalit2012.txt'' в каталоге [https://victorio.uit.no/langtech/trunk/courses/unix_korpus/]. Загрузите файл. Если Вы используете Mac и настроили папку как выше, и Вы стоите в папке __unixcourse__, Вы можете скопировать файл в папку __unixcourse__ с командой

__cp ../Downloads/eng_vaalit2012.txt .__

Последная точка в команде значит: "Скопируйте файл туда, где я теперь". Отметьте пространство между именем файла и точкой.

Как пример мы берем два предложения (если Вы практикуете, Вы можете скопировать их в отдельный документ, который Вы можете назвать __td-list__).:


{{{
cat eng_vaalit2012.txt | tr ' ' '\n' | grep '^d'
cat eng_vaalit2012.txt | tr ' ' '\n' | grep 'd$'
cat eng_vaalit2012.txt | tr ' ' '\n' | sort | uniq -c | sort -nr | head
}}}

Здесь мы также ввели новую команду, __head__. Команда __head__ выводит первые 10 строк из результата.

С помощью регулярных выражений мы можем получить различные наборы слов из текста. Следующие команды отфильтруют все слова, заканчивающиеся на {{-ate}}, на последовательности {{__a__ любой символ __e__}} или на последовательности {{__a__ любое число любых символов __e__}}. Заключительная команда дает все слова, заканчивающиеся на __d__, которому предшествует любой символ кроме __e__.

{{{
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'ate$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'a.*e$'
cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '[^e]d$'
}}}



Возможно тоже искать классы звуков. Таким образом [aeiouy] - класс всех гласных на английском языке. Этот поиск возвращает все слова, содержащие согласного __c__ с последующим любым гласным:

__grep 'c [aeiouy]' eng_vaalit2012.txt__


Регулярные выражения могут быть объединены. Как записать все случаи __o__ плюс любой  символ плюс гласный?

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep 'o.*[aeiouy]'__

Мы можем использовать скобки и для того, чтобы искать и заглавные и строчные буквы:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^in'__
__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|grep '^[Ii]n'__


Если мы хотим искать несколько последовательностей, нам нужна расширенная команда __grep__, __egrep__.
Здесь поиск всех слов, заканчивающихся на __-ing__ или __-ed__:

__cat vaalit2012.txt | tr ' ' '\n' | sort|uniq|egrep' (ing|ed)$'__



Больше информации о регулярных выражениях найдено на Википедии:
* [http://en .wikipedia.org/wiki/Regular_expression]
* [http://ru .wikipedia.org/wiki/Регулярные_выражения]


Встроенная система справочной информации Unix: __man__, __apropos__ и __info__

У Unix есть очень хорошая встроенная система справочной информации. Если Вы знаете название команды и хотите больше информации, Вы можете написать __man__ и названию команды (например, __man grep__). 

Есть две проблемы: Вы должны знать название команды, прежде чем Вы сможете спросить, и текст часто немного загадочный. Страницы __man__ лучше всего подходят, если Вы хотите узнавать, какие флаги использовать с командой, и как они работают.

Чтобы получить более образовательный текст, Вы можете написать __info__ вместо __man__. Если это тоже является слишком загадочным, Вы можете искать в Интернете. Чтобы получить объяснение на команду __cat__, Вы можете искать: Как использовать команду __cat__.

Если Вы не уверены в названии команде, которую Вы ищете, Вы можете написать __apropos__ название команды (например, __apropos search__). __apropos__ выводит Вам список названий команд, которые могли бы иметь некоторое отношение к слову (а возможно, нет!), которое Вы ввели. Обычно команда 'apropos' не настолько полезна.





Список команд Unix:

* [http://en .wikipedia.org/wiki/List_of_Unix_utilities]
* [http://ru .wikipedia.org/wiki/Программы_UNIX-подобных_операционных_систем]
