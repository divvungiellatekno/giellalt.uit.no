<html xmlns:xi="http://www.w3.org/2001/XInclude" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>An introduction to emacs</title>
      <authors>
         <person email="trond.trosterud@hum.uit.no" name="Trond Trosterud"></person>
      </authors>
   </head>
   <body>
      <h1>An introduction to emacs</h1>
      <p>Emacs is a very good editor, available on all unix systems, also when working on a
         remote machine. The
      </p>
      <h2>Crash course</h2>
      <p>To start emacs, write <em>emacs filename</em>, where <em>filename</em> is the name of the file you want to edit. Emacs will open the file you have requested.
         If you want to create a new file, then write the same command, and emacs will open
         with a blank page. In order to quit, press <em>C-x C-c</em> (where C-x means "hold down the ctrl key and press x"). Emacs will then ask you whether
         you want to save the file or not. If you suddenly are unable to type anything, and
         get strange messages on the screen, type <em>C-g</em> (interrupt)
      </p>
      <p>The best short emacs reference is found in the emacs chapter of OReillys <em>UNIX in a Nutshell</em>. Other references may be found below.
      </p>
      <h2>A short list of the most important commands</h2>
      <p>C = ctrl, M = meta (either ESC or Alt (Linux) or ESC (Mac). Note that on Linux, the
         key following meta is pressed at the same time as the meta key whereas on Mac, it
         is pressed after the ESC key have been released.
      </p>
      <p>Basic commands</p>
      <ul>
         <li><strong>C-g:
               </strong><br>Interrupt
         </li>
         <li><strong>C-s, C-x C-c:
               </strong><br>save, save and exit
         </li>
         <li><strong>C-w:
               </strong><br>write to file
         </li>
         <li><strong>C-x C-f filename:
               </strong><br>open the file "filename"
         </li>
      </ul>
      <p>Commands for searching in lexica</p>
      <ul>
         <li><strong>C-s example, C-r example:
               </strong><br>Search forward, search backward, after the string "example"
         </li>
         <li><strong>C-u C-s ^example:
               </strong><br>Search for the string "example" in the <strong>beginning</strong> of a line
         </li>
      </ul>
      <p>Moving around</p>
      <ul>
         <li><strong>C-a, C-e, C-n, C-p:
               </strong><br>beginning of line, end of line, next line, previous line.
         </li>
         <li><strong>C-v, M-v:
               </strong><br>next page, previous page
         </li>
         <li><strong>M-&gt;, M-&lt;
               :
               </strong><br>beginning of document, end of document
         </li>
      </ul>
      <h2>A tutorial</h2>
      <p>Much of what follow is taken from a text written by <a href="http://www.lib.uchicago.edu/keith/">
            <em>Keith Waclena</em>
            </a>.
      </p>
      <h3>Notation</h3>
      <p>In the rest of this document I use the standard Emacs notation to describe keystrokes:</p>
      <ul>
         <li><strong>
               <code>C-x</code>
               :
               </strong><br>For any <em>x</em>, the character Control-<em>x</em>.
         </li>
         <li><strong>
               <code>M-x</code>
               :
               </strong><br>For any <em>x</em>, the character
            Meta-<em>x</em>. Meta can be typed in two ways. M-v
            (scroll up, just to pick an example) may be typed ESC and
            then v (that is: Press ESC, take away your finger, and
            then press v). The faster way is to use the Meta key. If
            you use putty.exe on a Windows PC, the meta key could be
            Ctrl + Alt. Putty.exe has a Settings menu (TODO: have a
            look at putty). Anyway, M-x means "ESC, and
            thereafter x", or, equivalently, "hold down the
            Meta key(s) and press x".
         </li>
         <li><strong>
               <code>C-M-x</code>
               :
               </strong><br>For any <em>x</em>, the character Control-Meta-<em>x</em>.
         </li>
         <li><strong>
               <code>RET</code>
               :
               </strong><br>The return key (<code>C-m</code> actually). This is the key to the right of the letters, not the one in the lower
            right corner of the keyboard.
         </li>
         <li><strong>
               <code>SPC</code>
               :
               </strong><br>The space bar.
         </li>
         <li><strong>
               <code>ESC</code>
               :
               </strong><br>The escape key, or, equivalently, <code>C-[</code>
            
         </li>
      </ul>
      <h2>Emacs Command Structure</h2>
      <p>Every command has a long name, which you can look up in the documentation, like <code>kill-line</code>, <code>delete-backward-char</code>, or <code>self-insert-command</code>. These commands are <em>bound</em> to keystrokes for convenient editing. We call such a pairing of keystroke and command
         a key binding.
      </p>
      <h3>Prefix or Compound Keys</h3>
      <p>Prefix commands often group together commands that are somehow related.</p>
      <p>The standard prefix commands are:</p>
      <ul>
         <li><strong>
               <code>C-c</code>
               :
               </strong><br>Used for commands that are specific to particular <a href="#modes">modes</a>, so they are free to be used for different commands depending on context. These are
            the most variable of Emacs commands.
         </li>
         <li><strong>
               <code>C-h</code>
               :
               </strong><br>Used for Help commands.
         </li>
         <li><strong>
               <code>C-x</code>
               :
               </strong><br>This prefix is used mostly for commands that manipulate files, buffers and windows.
         </li>
      </ul>
      <p>There's one Emacs command that can be used to execute any other command by typing
         it's long name: <code>M-x</code>. When you type <code>M-x</code> Emacs prompts you for the name of any command, and then executes it.
      </p>
      <h3>The <code>ESC</code> Prefix
      </h3>
      <p>There's one other prefix command that's both very important and completely redundant:
         the <code>ESC</code> prefix.
      </p>
      <p>Not all keyboards provide a <code>Meta</code> key that sets the high order bit. On a PC running Emacs natively, the <code>ALT</code> key is used for <code>Meta</code>. But when using a PC to talk to a Unix box via some telecommunications program --
         well, you guessed it -- the <code>ALT</code> key may not work for this.
      </p>
      <p>But if you have no <code>Meta</code> key, all is not lost. You just use the <code>ESC</code> prefix. <code>M-a</code> becomes <code>ESC a</code>; <code>C-M-f</code> becomes <code>ESC C-f</code> (remember the equivalence of <code>C-M-f</code> and <code>M-C-f</code> and this will make sense).
      </p>
      <p>There's only one trick: <code>ESC</code> is <em>not</em> a shift key. It's actually an ASCII character, not a key modifier. This means that
         you don't try to hold down <code>ESC</code> at the same time as the other key: use it as a prefix character and type it separately
         and distinctly. If you lean on it it's likely to autorepeat (like any other key) and
         you'll get very confused.
      </p>
      <p>A true <code>Meta</code> is a wonderful thing for Emacs (it makes typing much faster), but it is possible
         to use <code>ESC</code> for years with no trouble.
      </p>
      <h2>Files, Buffers and Windows</h2>
      <p>Emacs has three data structures that are intimately related, and very important to
         understand:
      </p>
      <ul>
         <li><strong>
               <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Files">File</a>
               :
               </strong><br>A file is the actual Unix file on disk. You are never editing this file. Rather, you
            can read a copy into Emacs to initialize a buffer, and write a copy of a buffer out
            to a file to save it.
         </li>
         <li><strong>
               <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Buffers">Buffer</a>
               :
               </strong><br>A buffer is the internal data structure that holds the text you actually edit. Emacs
            can have any number of buffers active at any moment. Most, but by no means all, buffers
            are associated with a file. Buffers have names; a buffer that has been initialized
            from a file is almost always named for that file, and we say that the buffer is <em>visiting</em> the file. This means, in particular, that when you save the buffer, it's saved to
            the proper file. At any given time exactly one buffer is <em>selected</em>: this is the buffer that your hardware cursor is in, and this is where commands you
            type take effect (including self-insert commands). Buffers can be deleted at will;
            deleting a buffer in no way deletes the file on disk (though you may lose any editing
            changes you made if you don't save first).
         </li>
         <li><strong>
               <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Windows">Window</a>
               :
               </strong><br>A window is your view of a buffer. Due to limited screen real-estate, you may not
            have room to view all your buffers at once. You can split the screen, horizontally
            or vertically, into as many windows as you like (or at least have room for), each
            viewing a different buffer. It's also possible to have several windows viewing different
            portions of the same buffer. Windows can be created and deleted at will; deleting
            a window in no way deletes the buffer associated with the window. Each window has
            its own Mode Line, but there's still only one minibuffer.
         </li>
      </ul>
      <h3>Commands to Manipulate Files</h3>
      <ul>
         <li><strong>
               <code>C-x C-f</code>
               :
               </strong><br>
            <code>find-file</code>. This is the main command used to read a file into a buffer for editing. When you
            execute this command, it prompts you for the name of the file (with <a href="#completion">completion</a>). Then it checks to see if you're already editing that file in some buffer; if you
            are, it simply switches to that buffer and doesn't actually read in the file from
            disk again. If you're not, a new buffer is created, named for the file, and initialized
            with a copy of the file. In either case the current window is switched to view this
            buffer.
         </li>
         <li><strong>
               <code>C-x C-s</code>
               :
               </strong><br>
            <code>save-buffer</code>. This is the main command used to save a file, or, more accurately, to write a copy
            of the current buffer out to the disk, overwriting the buffer's file, and handling
            backup versions.
         </li>
         <li><strong>
               <code>C-x s</code>
               :
               </strong><br>
            <code>save-some-buffers</code>. Allows you to save all your buffers that are visiting files, querying you for each
            one and offering several options for each (save it, don't save it, peek at it first
            then maybe save it, etc).
         </li>
      </ul>
      <h3>Commands to Manipulate Buffers</h3>
      <ul>
         <li><strong>
               <code>C-x b</code>
               :
               </strong><br>
            <code>switch-to-buffer</code>. Prompts for a buffer name and switches the buffer of the current window to that
            buffer. Doesn't change your window configuration. This command will also create a
            <em>new</em> empty buffer if you type a new name; this new buffer will not be visiting any file,
            no matter what you name it.
         </li>
         <li><strong>
               <code>C-x C-b</code>
               :
               </strong><br>
            <code>list-buffers</code>. Pops up a new window which lists all your buffers, giving for each the name, modified
            or not, size in bytes, major mode and the file the buffer is visiting.
         </li>
      </ul>
      <h3>Commands to Manipulate Windows</h3>
      <ul>
         <li><strong>
               <code>C-v</code>
               :
               </strong><br>
            <code>scroll-up</code>. The basic command to scroll forward (toward the end of the file) one screenful.
            By default Emacs leaves you two lines of context from the previous screen.
         </li>
         <li><strong>
               <code>M-v</code>
               :
               </strong><br>
            <code>scroll-down</code>. Just like <code>C-v</code>, but scrolls backward.
         </li>
         <li><strong>
               <code>C-x o</code>
               :
               </strong><br>
            <code>other-window</code>. Switch to another window, making it the active window. Repeated invocation of this
            command moves through all the windows, left to right and top to bottom, and then circles
            around again. Under a windowing system, you can use the left mouse button to switch
            windows.
         </li>
         <li><strong>
               <code>C-x 1</code>
               :
               </strong><br>
            <code>delete-other-windows</code>. Deletes all other windows except the current one, making one window on the screen.
            Note that this in no way deletes the buffers or files associated with the deleted
            windows.
         </li>
         <li><strong>
               <code>C-x 0</code>
               :
               </strong><br>
            <code>delete-window</code>. Deletes just the current window, resizing the others appropriately.
         </li>
         <li><strong>
               <code>C-x 2</code>
               :
               </strong><br>
            <code>split-window-vertically</code>. Splits the current window in two, vertically. This creates a new window, but <em>not</em> a new buffer: the same buffer will now be viewed in the two windows. This allows
            you to view two different parts of the same buffer simultaneously.
         </li>
         <li><strong>
               <code>C-x 3</code>
               :
               </strong><br>
            <code>split-window-horizontally</code>. Splits the current window in two, horizontally. This creates a new window, but <em>not</em> a new buffer: the same buffer will now be viewed in the two windows. This allows
            you to view two different parts of the same buffer simultaneously.
         </li>
         <li><strong>
               <code>C-M-v</code>
               :
               </strong><br>
            <code>scroll-other-window</code>. Just like <code>C-v</code>, but scrolls the <em>other</em> window. If you have more than two windows, the other window is the window that <code>C-o</code> would switch to.
         </li>
      </ul>
      <h2>Fundamental Concepts</h2>
      <p>It's probably more important to understand these fundamental Emacs concepts than it
         is to understand any of the actual editing commands. The editing commands are details:
         you can learn them easily on your own if you get the groundwork right.
      </p>
      <h3>Entering and Exiting</h3>
      <p>To enter emacs, you just say:</p>
      <pre xml:space="preserve">emacs</pre>
      <p>when it comes up, you won't be editing any file. You can then use the file commands
         to read in files for editing. Alternatively, you can fire up Emacs with an initial
         file (or files) by saying:
      </p>
      <pre xml:space="preserve">emacs newfile.txt</pre>
      <p>To exit emacs, use the command <code>C-x C-c</code>. It will offer to save all your buffers and then exit.
      </p>
      <p>You can also <em>suspend</em> Emacs (in the Unix sense of stopping it and putting it in the background) with <code>C-x C-z</code> (which is bound to <code>suspend-emacs</code>). How you restart it is up to your shell, but is probably based on the <code>fg</code> command.
      </p>
      <h3>Self Inserting Commands</h3>
      <p>Once you've got Emacs running, you can type into it.</p>
      <h3>The Mode Line</h3>
      <p>The emacs screen is completely devoted to the text of your file, except for one line
         near the bottom of the screen: the mode line. This line is informational: you can
         never move into it. It's almost always in reverse video or otherwise highlighted.
         It displays important information (which may change), including:
      </p>
      <ul>
         <li>The <em>state</em> of the buffer, one of modified (indicated by a pair of asterisks), unmodified (hyphens),
            or read-only (indicated by a pair of <code>%</code> signs).
         </li>
         <li>The name of the file you're editing (it will be <code>*scratch*</code> if you're not editing any file).
         </li>
         <li>The major mode (in purines).</li>
         <li>The amount of the file that you can see on the screen: 
            <ul>
               <li><strong>All:
                     </strong><br>You can see all of the file.
               </li>
               <li><strong>Top:
                     </strong><br>You can see the top of the file.
               </li>
               <li><strong>Bot:
                     </strong><br>You can see the bottom of the file.
               </li>
               <li><strong>Percentage:
                     </strong><br>NV% indicates the percentage of the file above the top of the window.
               </li>
            </ul>
            
         </li>
      </ul>
      <h4>The Minibuffer</h4>
      <p>The blank line below the mode line is the <em>minibuffer</em>. The minibuffer is used by Emacs to display messages, and also for input when Emacs
         is prompting you to type something (it may want you to type yes or no in answer to
         a question, the name of a file to be edited, the long name of a command, etc).
      </p>
      <h3>Strange Messages</h3>
      <p>Emacs will occasionally print messages in the minibuffer of its own accord, seemingly
         unrelated to what you're doing. The two most common messages are "Mark set" and "Garbage
         collecting...". The former means that Emacs has set the mark for you as a result of
         your last command; automatic mark setting is a convenient feature of some commands;
         see <a href="#region">The Mark and The Region</a>. The latter means that Emacs' lisp engine is reclaiming storage. You can just ignore
         it and keep typing, if you like: Emacs won't lose your characters.
      </p>
      <h4>Long Lines</h4>
      <p>Emacs doesn't break lines for you automatically, unless you ask it to. By default
         it lets lines be as long as you type them.
      </p>
      <p>It may seem annoying to have to hit return at the end of long lines, but this is actually
         just the default for certain modes. The reason for this is that Emacs is a programmer's
         editor, and any editor that will insert line breaks without your telling it to isn't
         safe for editing code or data. In modes oriented towards text, Emacs does insert line
         breaks for you (Auto fill is such a mode)
      </p>
      <h3>Interrupting and Aborting</h3>
      <p>Sometimes Emacs will do something that you don't understand: it will prompt you for
         some information, or beep when you try to type, or something equally confusing. This
         just means that you've typed some command unwittingly (hitting a random function key
         is a good way to demonstrate this).
      </p>
      <p>When this happens, you just need to type <code>C-g</code>, which interrupts what Emacs is doing. This will get you out of any questions that
         Emacs may be asking you, and it will abort a partially typed key sequence (say if
         you typed C-x by mistake).
      </p>
      <p>Because Emacs is fully recursive, you may occasionally need to type <code>C-g</code> more than once, to back out of a recursive sequence of commands. Also, if Emacs is
         really wedged (say, in a network connection to some machine which is down), typing
         three <code>C-g</code>'s quickly is guaranteed to abort whatever's wedging you.
      </p>
      <h3>Help</h3>
      <p>Emacs has extensive online help, most of which is available when you press ESC, and
         thereafter help.
      </p>
      <ul>
         <li><strong>
               <code>ESC help a</code>
               :
               </strong><br>
            <code>command-apropos</code>. Prompts for a keyword and then lists all the commands with that keyword in their
            long name.
         </li>
         <li><strong>
               <code>ESC help k</code>
               :
               </strong><br>
            <code>describe-key</code>. Prompts for a keystroke and describes the command bound to that key, if any.
         </li>
         <li><strong>
               <code>ESC help i</code>
               :
               </strong><br>
            <code>info</code>. Enters the Info hypertext documentation reader.
         </li>
         <li><strong>
               <code>ESC help m</code>
               :
               </strong><br>
            <code>describe-mode</code>. Describes the current major mode and its particular key bindings.
         </li>
         <li><strong>
               <code>ESC help p</code>
               :
               </strong><br>
            <code>finder-by-keyword</code>. Runs an interactive subject-oriented browser of Emacs packages.
         </li>
         <li><strong>
               <code>ESC help t</code>
               :
               </strong><br>
            <code>help-with-tutorial</code>. Run the Emacs tutorial. This is very helpful for beginners.
         </li>
      </ul>
      <h3 id="info">Info</h3>
      <p>Emacs has a builtin hypertext documentation reader, called <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Misc%20Help">
            <em>Info</em>
            </a>. To run it, type <code>ESC help i</code> or <code>M-x info RET</code>. It has it's own tutorial, which you should run the first time through by typing
         <code>h</code>. The tutorial assumes you understand about as much about Emacs as is covered in this
         document.
      </p>
      <h3>Infinite Undo with Redo</h3>
      <p>One of the most important Emacs commands is <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Undo">
            <code>undo</code>
            </a>, invoked with <code>C-_</code> (control underbar). <code>C-_</code> is a valid ASCII character, but some keyboards don't generate it, so you can also
         use <code>C-x u</code> -- but it's more awkward to type, since it's a two-character command.
      </p>
      <p>The undo command allows you to undo your editing, back in time. It's handy when you
         accidentally convert all of a huge file to uppercase, say, or delete a huge amount
         of text. One keystroke changes everything back to normal.
      </p>
      <p>We say Emacs has infinite undo because, unlike some editors, you can undo a long chain
         of commands, not just one previous one, even undoing through saves. We say Emacs has
         redo because you can reverse direction while undoing, thereby undoing the undo.
      </p>
      <p>Once you get used to this feature you'll laugh at any editor that doesn't have it
         (unless you're forced to use it...). It's very important to get comfortable with undo
         as soon as possible; I recommend reading <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Undo">the undo section of the manual</a> carefully and practicing.
      </p>
      <h3>Backups and Auto Save Mode</h3>
      <p>Emacs never modifies your file on disk until you tell it to, but it's very careful
         about saving your work for you in a number of ways.
      </p>
      <ul>
         <li><strong>
               <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Backup">Backup files</a>.:
               </strong><br>Emacs always saves the previous version of your file when you save. If your file is
            named <code>foo</code>, the backup will be called <code>foo~</code> (note the squiggle). Although it is off by default, Emacs will keep any number of
            previous versions for you, named <code>foo.~1~</code>, <code>foo.~2~</code>, etc. You can decide how many versions are to be kept. (But Unix provides more powerful
            tools for managing multiple versions of files.)
         </li>
         <li><strong>
               <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Auto%20Save">Auto-Save files</a>.:
               </strong><br>Emacs also, be default, <em>auto-saves</em> your file while you're editing it. The auto-save file for a file <code>foo</code> is called <code>#foo#</code>. If Emacs (or the system) were to crash before you could save your edits, you can
            recover almost all of it from this file. Auto-saving happens (by default) every 300
            characters, or when a system error is encountered.
         </li>
      </ul>
      <h3 id="completion">Completion</h3>
      <p>To save you typing, Emacs offers various forms of <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Completion">
            <em>completion</em>
            </a>: this means Emacs tries to complete for you partially typed file names, command names,
         etc. To invoke completion, you usually type <code>TAB</code>.
      </p>
      <h3>Giving Commands Arguments</h3>
      <p>Many Emacs commands take <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Arguments">
            <em>arguments</em>
            </a>, exactly the way a procedure or function takes arguments in a programming language.
         Most commands prompt you for their arguments: e.g., a command to read in a file will
         prompt you for the filename.
      </p>
      <p>There's one kind of argument that's so commonly accepted that there's a special way
         to provide it: <em>numeric arguments</em>. Many commands will interpret a numeric argument as a request to repeat that many
         times. For example, the <code>delete-char</code> command (bound to <code>C-d</code>), which normally deletes one character to the right of the cursor, will delete <em>N</em> characters if given a numeric argument of <em>N</em>. It works with self-inserting commands too: try giving a numeric argument to a printing
         character, like a hyphen.
      </p>
      <p>To give a command a numeric argument of, say, 12, type <code>C-u 12</code> before typing the command. If you type slowly, you'll see:
      </p>
      <pre xml:space="preserve">C-u 1 2-</pre>
      <p>in the echo area. Then type <code>C-d</code> and you'll have given <code>delete-char</code> an argument of 12. You can type any number of digits after <code>C-u</code>. A leading hyphen makes a negative argument; a lone hyphen is the same as an argument
         of -1. If you begin typing a numeric argument and change your mind, you can of course
         type <code>C-g</code> to abort it.
      </p>
      <p>Since one often isn't interested in <em>precisely</em> how many times a command is repeated, there's a shorthand way to get numeric arguments
         of varying magnitudes. <code>C-u</code> by itself, without any subsequent digits, is equal to a numeric argument of 4. Another
         <code>C-u</code> multiplies that by 4 more, giving a numeric argument of 16. Another <code>C-u</code> multiplies <em>that</em> by 4 more, giving a numeric argument of 64, etc. For this reason <code>C-u</code> is called the <code>universal-argument</code>.
      </p>
      <p>Note that commands aren't <em>required</em> to interpret numeric arguments as specifying repetitions. It depends on what's appropriate:
         some commands ignore numeric arguments, some interpret them as Boolean (the presence
         of numeric argument -- <em>any</em> numeric argument -- as opposed to its absence), etc. Read the documentation for a
         command before trying it.
      </p>
      <h3>Quoting Characters That Are Bound As Commands</h3>
      <p>Sometimes one needs to insert control characters into a file. But how can you insert
         an <code>ESC</code>, say, when it's used as a prefix command? The answer is to use the command <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Inserting%20Text">
            <code>quoted-insert</code>
            </a>, which is bound to <code>C-q</code>. <code>C-q</code> acts like a prefix command, in that when you type it it waits for you to type another
         character. But this next character is then inserted into the buffer, rather than being
         executed as a command. So <code>C-q ESC</code> inserts an <code>Escape</code>.
      </p>
      <p>
         <code>C-q</code> can also be used to insert characters by typing <code>C-q</code> followed by their ASCII code as three octal digits.
      </p>
      <h3>Disabled Commands</h3>
      <p>Some commands that are especially confusing for novices are <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Disabling">disabled</a> by default. When a command is disabled, invoking it subjects you to a brief dialog,
         popping up a window displaying the documentation for the command, and giving you three
         choices:
      </p>
      <ul>
         <li>Space to try the command just this once, but leave it disabled,</li>
         <li>Y to try it and enable it (no questions if you use it again),</li>
         <li>N to do nothing (command remains disabled).</li>
      </ul>
      <p>You're very likely to encounter one particular disabled command: <code>M-ESC</code> (aka <code>ESC ESC</code>), because it's very easy to type two escapes in a row when using the <code>Escape</code> prefix.
      </p>
      <h2>Motion and Objects</h2>
      <p>One of the main things one does in an editor is <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Moving%20Point">move around</a>, in order to apply editing commands. Emacs provides many motion commands, which are
         arranged around <em>textual objects</em>: for each textual object, there is typically a motion command that moves forward
         over such an object and backward over it (or you can think of this as moving to the
         beginning and to the end).
      </p>
      <p>All these motion commands take numeric arguments as repetitions.</p>
      <p>The most basic textual object is the character. Emacs understand many other objects,
         sometimes depending on what mode you're in (a C function textual object probably doesn't
         make much sense if you're not editing C source code).
      </p>
      <p>The exact definition of what makes up a given textual object is often customizable,
         but more importantly varies slightly from mode to mode. The characters that make up
         a word in Text Mode may not be exactly the same as those that make up a word in C
         Mode for example. (E.g., underbars are considered word constituents in C Mode, because
         they are legal in identifier names, but they aren't considered word constituents in
         Text Mode.) This is extremely useful, because it means that you can use the same motion
         commands and yet have them automatically customized for different types of text.
      </p>
      <h3>Characters</h3>
      <ul>
         <li><strong>
               <code>C-f</code>
               :
               </strong><br>
            <code>forward-char</code>. Moves forward (to the right) over a character.
         </li>
         <li><strong>
               <code>C-b</code>
               :
               </strong><br>
            <code>backward-char</code>. Moves backward (to the left) over a character.
         </li>
      </ul>
      <p>The f for forward and b for backward mnemonic will reoccur.</p>
      <h3>Words</h3>
      <ul>
         <li><strong>
               <code>M-f</code>
               :
               </strong><br>
            <code>forward-word</code>. Moves forward over a word.
         </li>
         <li><strong>
               <code>M-b</code>
               :
               </strong><br>
            <code>backward-word</code>. Moves backward over a word.
         </li>
      </ul>
      <p>Note the f/b mnemonic. Also, as another mnemonic, note that <code>M-f</code> is like a "bigger" version of <code>C-f</code>.
      </p>
      <h3>Lines (vertically)</h3>
      <ul>
         <li><strong>
               <code>C-n</code>
               :
               </strong><br>
            <code>next-line</code>. Moves down to the next line.
         </li>
         <li><strong>
               <code>C-p</code>
               :
               </strong><br>
            <code>previous-line</code>. Moves up to the previous line.
         </li>
      </ul>
      <p>When moving by lines, the cursor tries to stay in the same column, but if the new
         line is too short, it will be at the end of the line instead. This is very important:
         Emacs doesn't insert spaces at the ends of lines (end of line is unambiguous).
      </p>
      <h3>Lines (horizontally)</h3>
      <ul>
         <li><strong>
               <code>C-a</code>
               :
               </strong><br>
            <code>beginning-of-line</code>. Moves to the beginning of the current line.
         </li>
         <li><strong>
               <code>C-e</code>
               :
               </strong><br>
            <code>end-of-line</code>. Moves to the end of the current line.
         </li>
      </ul>
      <p>E for end, A for the beginning of the alphabet.</p>
      <h3>Sentences</h3>
      <ul>
         <li><strong>
               <code>M-a</code>
               :
               </strong><br>
            <code>backward-sentence</code>. Moves to the beginning of the current sentence.
         </li>
         <li><strong>
               <code>M-e</code>
               :
               </strong><br>
            <code>forward-sentence</code>. Moves to the end of the current sentence.
         </li>
      </ul>
      <p>Note the mnemonic relation between <code>C-a</code> / <code>M-a</code> and <code>C-e</code> / <code>M-e</code>.
      </p>
      <h3>Paragraphs</h3>
      <ul>
         <li><strong>
               <code>M-{</code>
               :
               </strong><br>
            <code>backward-paragraph</code>. Move to the beginning of the current paragraph.
         </li>
         <li><strong>
               <code>M-}</code>
               :
               </strong><br>
            <code>forward-paragraph</code>. Move to the end of the current paragraph.
         </li>
      </ul>
      <h3>Pages</h3>
      <ul>
         <li><strong>
               <code>C-x [</code>
               :
               </strong><br>
            <code>backward-page</code>. Moves to the beginning of the current page.
         </li>
         <li><strong>
               <code>C-x ]</code>
               :
               </strong><br>
            <code>forward-page</code>. Moves to the end of the current page.
         </li>
      </ul>
      <p>Pages are separated by formfeed characters (<code>C-l</code>) in most modes.
      </p>
      <h3>Buffers</h3>
      <ul>
         <li><strong>
               <code>M-&lt;</code>
               :
               </strong><br>
            <code>beginning-of-buffer</code>. Moves to the beginning of the buffer.
         </li>
         <li><strong>
               <code>M-&gt;</code>
               :
               </strong><br>
            <code>end-of-buffer</code>. Moves to the end of the buffer.
         </li>
      </ul>
      <h3>S-Expressions (balanced parentheses)</h3>
      <p>An <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)List%20Commands">
            <em>S-expression</em>
            </a> (<em>sexp</em> for short) is the name for balanced parentheses (and the text they enclose) in Lisp.
         In Emacs, this useful notion is available in most modes; it's especially useful for
         editing programming languages. The characters that Emacs recognizes as parens are
         usually regular parentheses (aka round brackets), square brackets, and braces (aka
         curly brackets), but it depends on the mode (for some languages, angle brackets may
         act as parens).
      </p>
      <p>But sexps are more than just balanced parens: they're defined recursively. A word
         that doesn't contain any parens also counts as a sexp. In most programming language
         modes, quoted strings are sexps (using either single or double quotes, depending on
         the syntax of the language). The sexp commands move in terms of all these units.
      </p>
      <p>These commands may seem confusing at first, but for editing most programming languages
         they're fantastic. Not only do they move you around quickly and accurately, but they
         help spot syntax errors while you're editing, because they'll generate an error if
         your parens or quotes are unbalanced.
      </p>
      <ul>
         <li><strong>
               <code>C-M-b</code>
               :
               </strong><br>
            <code>backward-sexp</code>. Moves backward over the next sexp. If your cursor is just to the right of a left
            paren, <code>C-M-b</code> will beep, because there's no sexp to the left to move over: you have to move <em>up</em>.
         </li>
         <li><strong>
               <code>C-M-f</code>
               :
               </strong><br>
            <code>forward-sexp</code>. Moves forward over the next sexp. Same deal if your cursor is just to the left of
            a right paren.
         </li>
         <li><strong>
               <code>C-M-u</code>
               :
               </strong><br>
            <code>backward-up-list</code>. Move backward up one level of parens. In other words, move to the left paren of
            the parens containing the cursor, skipping balanced sexps.
         </li>
         <li><strong>
               <code>C-M-d</code>
               :
               </strong><br>
            <code>down-list</code>. Move down one level of parens. In other words, move to the right of the next left
            paren, skipping balanced sexps. E.g., if your cursor is sitting on the return type
            of a C function declaration, <code>C-M-d</code> moves to the inside of the formal parameter list.
         </li>
      </ul>
      <h3>Functions</h3>
      <p>Since <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Defuns">functions</a> are such an important unit of text in programming languages, whether they're called
         functions, subroutines, procedures, procs, defuns or whatever, Emacs has commands
         to move over them. Like the sexp commands, these commands work appropriately in most
         programming language modes. Emacs calls this generic notion of function or procedure
         <em>defun</em>, again after Lisp.
      </p>
      <ul>
         <li><strong>
               <code>C-M-a</code>
               :
               </strong><br>
            <code>beginning-of-defun</code>. Move to the beginning of the current defun.
         </li>
         <li><strong>
               <code>C-M-e</code>
               :
               </strong><br>
            <code>end-of-defun</code>. Move to the end of the current defun.
         </li>
      </ul>
      <p>Note the mnemonic analogy with lines and sentences.</p>
      <h2>Deleting, Killing and Yanking</h2>
      <p>Emacs' deletion commands are also based on the textual objects above. But first, a
         terminological distinction: <em>Deletion</em> means to remove text from the buffer without saving it; most deletion commands operate
         on small amounts of text. <em>Killing</em> means to save the removed text, so that it can be yanked back later someplace else.
         So, "Deletion" is permanent, "Killing" is deletion that can be undone, and "yanking"
         is the emacs term for paste.
      </p>
      <p>Killed text is saved on what is called the kill ring. The kill ring holds the last
         <em>N</em> kills, where <em>N</em> is 30 by default, but you can change it to anything you like by changing the value
         of the variable <code>kill-ring-max</code>. The kill ring acts like a fifo when you're killing things (after the 30th kill,
         kill number one is gone), but like a ring when you're yanking things back (you can
         yank around the ring circularly). <code>kill-ring-max</code> doesn't apply to the amount of text (in bytes) that can be saved in the kill ring
         (there's no limit), only to the number of distinct kills.
      </p>
      <h3>Characters</h3>
      <ul>
         <li><strong>
               <code>C-d</code>
               :
               </strong><br>
            <code>delete-char</code>. Deletes the character to the right of (under, if the cursor is a block that covers
            a character) the cursor.
         </li>
         <li><strong>
               <code>DEL</code>
               :
               </strong><br>
            <code>delete-backward-char</code>. Deletes the character to the left of the cursor.
         </li>
      </ul>
      <h3>Words</h3>
      <ul>
         <li><strong>
               <code>M-d</code>
               :
               </strong><br>
            <code>kill-word</code>. Kills to the end of the word to the right of the cursor (forward).
         </li>
         <li><strong>
               <code>M-DEL</code>
               :
               </strong><br>
            <code>backward-kill-word</code>. Kills to the beginning of the word to the left of the cursor (backward).
         </li>
      </ul>
      <h3>Lines (horizontally)</h3>
      <ul>
         <li><strong>
               <code>C-k</code>
               :
               </strong><br>
            <code>kill-line</code>. Kills to the end of the current line, not including the newline. Thus, if you're
            at the beginning of a line it takes two <code>C-k</code>'s to kill the whole line and close up the whitespace.
         </li>
         <li><strong>
               <code>C-u 0 C-k</code>
               :
               </strong><br>
            <code>kill-line</code>. Kills to the beginning of the current line, not including the newline.
         </li>
      </ul>
      <p>You might think that <code>C-u -1 C-k</code> would be used to kill to the beginning of the line, and it does, but it includes
         the newline before the line as well.
      </p>
      <h3>Sentences</h3>
      <ul>
         <li><strong>
               <code>M-k</code>
               :
               </strong><br>
            <code>kill-sentence</code>. Kills to the end of the current sentence, including any newline within the sentence.
         </li>
         <li><strong>
               <code>C-u -1 M-k</code>
               :
               </strong><br>
            <code>kill-sentence</code>. Kills to the beginning of the current sentence, including any newlines within the
            sentence.
         </li>
      </ul>
      <h3>Paragraphs</h3>
      <p>The commands <code>forward-kill-paragraph</code> and <code>backward-kill-paragraph</code> exist, but are not bound to any keys by default.
      </p>
      <ul>
         <li><strong>
               <code>C-M-k</code>
               :
               </strong><br>
            <code>kill-sexp</code>. Kills the sexp after the cursor.
         </li>
         <li><strong>
               <code>C-u -1 C-M-k</code>
               :
               </strong><br>
            <code>kill-sexp</code>. Kills the sexp before the cursor.
         </li>
      </ul>
      <p>The command <code>backward-kill-sexp</code> exists, but is not bound to any key by default.
      </p>
      <h3>Extending Kills</h3>
      <p>If you kill several times in a row, with any combination of kill commands, but without
         any <em>non</em>-kill commands in between, these kills are appended together in one entry on the kill
         ring. For example you can kill a block of text as several lines by saying <code>C-u 6 C-k</code>, which kills (as one kill) 6 lines.
      </p>
      <h3>Yanking (what other programs call "paste"</h3>
      <p>Once you've killed some text, how do you get it back? You can yank back the most recently
         killed text with <code>C-y</code> (<code>yank</code>). Since Emacs has only one kill ring (as opposed to one per buffer), you can kill
         in one buffer, switch to another and yank the text there.
      </p>
      <p>To get back previous kills, you move around the kill ring. Start with <code>C-y</code> to get the most recent kill, and then use <code>M-y</code> to move to the previous spot in the kill ring by replacing the just-yanked text with
         the previous kill. Subsequent <code>M-y</code>'s move around the ring, each time replacing the yanked text. When you reach the text
         you you're interested in, just stop. Any other command (a motion command, self-insert,
         anything) breaks the cycling of the kill ring, and the next <code>C-y</code> yanks the most recent kill again.
      </p>
      <h2>Copying and Moving Text</h2>
      <p>Emacs has no need for special commands to copy or move text; you've already learned
         them! To move text, just kill it and yank it back elsewhere. To copy text, kill it,
         yank it back immediately (so it's as if you haven't killed it, except it's now in
         the kill ring), move elsewhere and yank it back again. For commands to copy and move
         arbitrary regions of text, as opposed to textual objects, see <a href="#region">The Mark and The Region</a>.
      </p>
      <h2>Searching and Replacing</h2>
      <p>Emacs has a variety of unusual and extremely powerful search and replace commands.
         The most important one is called <em>incremental search</em>. This is what the command <code>C-s</code>, does: it searches incrementally, one character at a time, as you type the search
         string. This means that Emacs can often find what you're looking for before you have
         to type the whole thing. To stop searching, you can either hit <code>RET</code> or type any other Emacs command (which will both stop the search and execute the
         command). You can search for the next match at any point by typing another <code>C-s</code> at any point; you can reverse the search (search backwards) by typing <code>C-r</code>; and you can use <code>DEL</code> to delete and change what you're searching for.
      </p>
      <p>
         <code>C-r</code>, works the same way, but searches backward. (Use <code>C-r</code> to search for the next match and <code>C-s</code> to reverse the search.)
      </p>
      <p>Another possibility is <em>word search</em>, which lets you search for a sequence of one or more words, regardless of how they're
         separated (e.g, by any number and combination of newlines and whitespace). To invoke
         word search, type <code>C-s RET C-w word word word RET</code>.
      </p>
      <p>Emacs can also search incrementally (or not) by regular expressions. The command is
         <code>C-u-s</code>, and it understands <a href="../ling/docu-regexps.html">regular expressions</a>.
      </p>
      <h3>Replacement</h3>
      <p>Emacs' most important command for replacing text is called <code>query-replace</code> (bound to <code>M-%</code>, type <strong>ESC</strong>, and thereafter <strong>%</strong>). This command prompts you for the text to replace, and the text to replace it with,
         and then searches and replaces within the current buffer. <code>query-replace</code> is interactive: at each match, you are prompted to decide what to do; you have the
         following options:
      </p>
      <ul>
         <li><strong>
               <code>SPC</code>
               :
               </strong><br>Perform this replacement.
         </li>
         <li><strong>
               <code>DEL</code>
               :
               </strong><br>Don't perform this replacement.
         </li>
         <li><strong>
               <code>RET</code>
               :
               </strong><br>Terminate <code>query-replace</code> without performing this replacement.
         </li>
         <li><strong>
               <code>ESC</code>
               :
               </strong><br>Same as <code>RET</code>.
         </li>
         <li><strong>
               <code>.</code>
               :
               </strong><br>Perform this replacement but then terminate the <code>query-replace</code>.
         </li>
         <li><strong>
               <code>!</code>
               :
               </strong><br>Perform this replacement and all the rest in the buffer without querying (ie unconditionally).
         </li>
      </ul>
      <p>There are many more subcommands, but they require more Emacs expertise to understand
         them.
      </p>
      <p>There are also more replacement commands you should look into, including <code>replace-string</code> (simple unconditional replacement), <code>replace-regexp</code> and <code>query-replace-regexp</code> (which use regular expressions), and <code>tags-query-replace</code>, which replaces all identifiers in a collection of source code files.
      </p>
      <p>
         <code>query-replace-regexp</code> is <strong>very important</strong> to us. The shortest way to type it is <strong>ESC que TAB - TAB</strong>. If you e.g. want to add the text <strong>K ;</strong> to the end of each line of the rest of the file, type <strong>ESC que TAB - TAB</strong>, then <strong>$ RET</strong> (dollar followed by return, dollar means end-of-line), then <strong>K ;</strong> followed by return.
      </p>
      <p>
         <code>query-replace</code> and the other replacement commands are, by default, smart about case. For example,
         if you're replacing <code>foo</code> with <code>bar</code> and find <code>Foo</code>, Emacs replaces it with <code>Bar</code>; if you find <code>FOO</code>, Emacs replaces it with <code>BAR</code>, etc.
      </p>
      <h2>The Mark and The Region</h2>
      <p>Emacs can manipulate arbitrary chunks of text as well as distinct textual objects.
         The way this is done is to define a <em>region</em> of text; many commands will operate on this region. this is what you do with the
         mouse in ordinary word processors.
      </p>
      <p>The region is the text between <em>point</em> and <em>mark</em>. Point is actually the Emacs term for what we've been calling the cursor up to now.
         The mark, on the other hand, is set with a special command <code>C-SPACEBAR</code> (mellomromstasten, vlilynti) (<code>set-mark-command</code>). This sets the mark exactly where point is, but now you can move point elsewhere
         and you have: the region.
      </p>
      <p>The region is the same regardless of whether point comes first in the buffer or mark
         does; it makes no difference, just do what's convenient.
      </p>
      <p>Many commands that move point a significant distance (like <code>M-&lt;</code> and <code>C-s</code>, for example) leave the mark set at the spot they moved from. You'll see "Mark set"
         in the echo area when this happens.
      </p>
      <p>When using Emacs under a windowing system like X, the mouse can be used to sweep out
         the region, but many Emacsers find it faster to keep their hands on the keyboard and
         use the familiar motion commands.
      </p>
      <p>So now you know how to define the region: what can you do with it?</p>
      <ul>
         <li><strong>
               <code>C-x C-x</code>
               :
               </strong><br>
            <code>exchange-point-and-mark</code>. Swaps mark and point. Repeated rapid execution of this command makes it easy to
            see the extent of the region.
         </li>
         <li><strong>
               <code>C-w</code>
               :
               </strong><br>
            <code>kill-region</code>. Kills the region. It goes on the kill ring, of course.
         </li>
         <li><strong>
               <code>M-w</code>
               :
               </strong><br>
            <code>kill-ring-save</code>. Saves the region to the kill ring without removing it from the buffer. This is exactly
            equivalent to typing <code>C-w C-y</code>.
         </li>
         <li><strong>
               <code>C-x C-i</code>
               :
               </strong><br>
            <code>indent-rigidly</code>. Rigidly indents the region by as many characters (columns) as you provide as a numeric
            argument (default is 1 column).
         </li>
         <li><strong>
               <code>C-x C-l</code>
               :
               </strong><br>
            <code>downcase-region</code>. Convert the entire region to lowercase. This command is disabled by default.
         </li>
         <li><strong>
               <code>C-x C-u</code>
               :
               </strong><br>
            <code>upcase-region</code>. Convert the entire region to uppercase. This command is disabled by default.
         </li>
         <li><strong>
               <code>M-x fill-region</code>
               :
               </strong><br>
            <code>fill-region</code>. Fills, i.e., justifies with a ragged right margin, all the paragraphs within the
            region.
         </li>
      </ul>
      <p>There are many, many more.</p>
      <h2 id="modes">Modes</h2>
      <p>The main way Emacs customizes commands for different kinds of text is through major
         and minor modes. Every buffer has a major mode, and may have zero or more minor modes.
         Sometimes Emacs chooses a major mode for you automatically, typically based on a file
         extension (e.g., files ending in <code>.c</code> will automatically be in C Mode; files ending in <code>.tcl</code> will automatically be in Tcl Mode). But you can always set the mode explicitly.
      </p>
      <h3>Some Major Modes</h3>
      <ul>
         <li><strong>
               <code>Fundamental Mode</code>
               :
               </strong><br>The basic mode in reference to which all specialized modes are defined. Perfectly
            fine for editing any kind of text, just doesn't provide any special features.
         </li>
         <li><strong>
               <code>Text Mode</code>
               :
               </strong><br>For editing text. Has special commands for spell-checking, centering lines, etc.
         </li>
         <li><strong>
               <code>HTML helper mode</code>
               :
               </strong><br>for writing html files. It is automatically turned on when you open a file with a
            name that ends in ".html".
         </li>
      </ul>
      <p>There are many other major modes, some very specialized (e.g., modes for editing sending
         email, reading Usenet news, browsing directories, browsing the World Wide Web, etc).
      </p>
      <h3>Entering characters in Emacs</h3>
      <ul>
         <li><strong>
               <code>ISO Latin characters</code>
               :
               </strong><br>
            
            <ul>
               <li>Type <code>C-q</code> followed by the octal code of the character. For example, <code>C-q 341 RET</code> gives the lower case a with acute ().
               </li>
               <li>First load the iso-insert library: give the command <code>M-x load-library</code> and respond to prompt with <code>iso-insert</code>. Then use commands <code>M-x insert-A-acute</code> for inserting capital A with acute ().
               </li>
            </ul>
            
         </li>
         <li><strong>
               <code>UTF-8 characters</code>
               :
               </strong><br>
            
            <ul>
               <li>First load library <code>un-define</code>
                  
               </li>
               <li>Insert unicode characters by <code>M-x insert-ucs-character</code> and giving the character's unicode number.
               </li>
            </ul>
            
         </li>
      </ul>
      <h2>Further Information</h2>
      <h3>GNU Emacs Frequently Asked Questions List</h3>
      <p>The <a href="http://www.eecs.nwu.edu/emacs/faq/index.html">GNU Emacs FAQ</a> is very well done; I recommend it highly.
      </p>
      <h3>Info</h3>
      <p>Don't forget that the complete text of the <em>GNU Emacs Manual</em> is available via <a href="#info">Info</a>, Emacs' hypertext documentation reader.
      </p>
      <h3>Usenet Newsgroups</h3>
      <p>Only a selection of some of the Emacs-related Usenet newsgroups.</p>
      <ul>
         <li><strong>
               <a href="news:gnu.emacs.help">gnu.emacs.help</a>
               :
               </strong><br>Help for users' GNU Emacs problems, answered by your peers.
         </li>
         <li><strong>
               <a href="news:comp.emacs">comp.emacs</a>
               :
               </strong><br>General coverage of all Emacs-like editors.
         </li>
         <li><strong>
               <a href="news:gnu.emacs.announce">gnu.emacs.announce</a>
               :
               </strong><br>Announcements of new versions of GNU Emacs, etc.
         </li>
         <li><strong>
               <a href="news:alt.religion.emacs">alt.religion.emacs</a>
               :
               </strong><br>Emacs as religion. Official home of the perennial flame wars.
         </li>
         <li><strong>
               <a href="news:gnu.emacs.sources">gnu.emacs.sources</a>
               :
               </strong><br>Postings of source code for new GNU Emacs programs.
         </li>
      </ul>
      <h3>Bibliography</h3>
      <ul>
         <li>Richard M. Stallman. <em>GNU Emacs Manual</em>. Cambridge, MA: Free Software Foundation, [n.d.]. The authoritative user's reference;
            also a fine introduction. The complete text is <a href="http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)">available on the Web</a> and via <a href="#info">Info</a>.
         </li>
         <li>Debra Cameron and Bill Rosenblatt. <em>Learning GNU Emacs</em>. Sebastopol, CA: O'Reilly and Associates, 1991. A good introduction. Covers version
            18 only.
         </li>
         <li>Michael A. Schoonover et al. <em>GNU Emacs: Unix Text Editing and Programming</em>. Reading, MA: Addison-Wesley, 1992.
         </li>
         <li>Bill Lewis, Dan LaLiberte, and the GNU Manual Group. <em>GNU Emacs Lisp Reference Manual</em>. Cambridge, MA: Free Software Foundation, 1993. Covers version 19 Elisp. Only if
            you want to learn to program in Emacs Lisp. The complete text is <a href="http://www.cs.indiana.edu/elisp/lispref/elisp_toc.html">available on the Web</a> and via <a href="#info">Info</a>.
         </li>
         <li>Richard M. Stallman. "EMACS: The Extensible, Customizable, Self-Documenting Display
            Editor". In <em>Interactive Programming Environments</em>, edited by David R. Barstow, Howard E. Shrobe, and Erik Sandewall. New York: McGraw-Hill,
            1984. An interesting article on the design of Emacs. Predates GNU Emacs; covers the
            original <a href="news:alt.lang.teco">TECO</a> Emacs and Lisp Machines Emacsen.
         </li>
      </ul>
   </body>
</html>